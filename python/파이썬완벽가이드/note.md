# note

읽으면서 기억나는 것들 적거나, 키워드만 작성해둔다.

## 1장

- 코루틴, 제너레이터는 호출시 객체 반환.
- dir() : 객체가 제공하는 method 나열 또는 모듈의 내용 나열 27p
- 이름이 밑줄로 시작하는 경우 31p
- 모듈 namespace
  ```python
  import string
  dir(string)
  # TODO: 근데 string 모듈 안에 있는 import문의 내용들도 string namespace에 들어 올까? 
  ```

## 2장

- 🤩 py3 문자열 인코딩
  - <https://dojang.io/mod/page/view.php?id=2462>

## 3장 타입과 객체

- 참조,복사 43p
- 객체 신원과 타입 40p
  - id, type 내장 함수 
- 1급객체 -> 함수형 프로그래밍 개념.
  - 45p 예시 신기
- 🌟 is, isinstance, ==,id ->40p
- 참조횟수 41p
- 🌟얕은 복사, 깊은 복사. immutable, mutable p42
- None
- min, max
- 문자열 p49
  - py3에는 encode는 문자열에만, decode는 바이트 데이터에만 존재
- format string.. 
  - > 이거 {변수이름} 쓰면 문자열에서 자동으로 해당 변수 넣어주는 것도 있었음
- 사전 53p
  - copy 함수, `list(m) # m은 사전`
- set은 순서가 없다. 
  - 즉, index및 분할 연산 안됨
  - 변경 가능 집합, 불가능 집합 있다.
  - 내장 합수 set, frozenset으로 만듬
- callable type p57
  - 사용자 정의 함수
    - 여러 attribute 존재. `__dic__, __code__` 등
  - 매서드 p59
    - class method, instance method, static method 존재
      - > 근데 class method, static method개념이 cpp,java에도 있었나?
    - bound method, unbound method
    - 🌟 python에서 method 호출 원리 나옴.
  - 호출 가능한 class와 instance , 60p
    - class 객체의 경우 `()`로 호출하면 `__init__()`에 의해 생성된 객체의 초기화 진행
    - instance의 경우 `__call__()`을 정의하면 함수객체(functor)로 쓸수 있음 (함수 객체는 내가 적은 표현.. 아마 맞는 개념일듯) 
  - 클래스, 타입, 인스턴스
    - 일반적인 class의 type은 type으로 나옴 60p -> class FOO에 대한 `type(FOO)` 이 type이 나온다는 것
    - 각각의 attribute 61p
      - > 이거 알아두면 좋으니 항상 확인해 볼것
    - `__slot__` 을 클래스에서 쓰면 더 효율적 `__dict__` 가 안쓰이므로.. 
      - > class객체에도 dict가 있는데 slot을 쓰면 인스턴스 객체의 dict가 안쓰인다는 것일듯
- 매핑 타입 집합 타임, 53p
- 모듈 61p  
- 내장 객체
  - 제너레이터도 따로 객체 type이네,   
  - 마찬가지로 slice함수나 리스트의`[::stride]` 같은 확장 분할로 리스트 slicing하면 분할 객체가 반환됨 (근데 이부분은 잘 이해 안감)
  - ellipsis 객체 -> `[]`안에서 ... 쓸때 생성
- 객체 작동 방식 및 특수 메서드 65p
  - 왜 문자열 리스트 튜플이 같이 묶이는지?
  - +,- 연산은 어떻게 구현되는지?
- 객체 생성 및 파괴
  - `__new__` 로 생성 `__init__`으로 초기화 `__del__`은 객체 파괴될때 호출됨 
  - `del x` 하는 경우 x 객체의 참조횟수를 줄이는거지 반드시 `__del__`호출하는 것은 아님
  - `__new__`는 보통 immutable type을 상속받은 사용자 정의 객체나, 메타클래스에서만 사용
  - `__del__`은 락 해제, 연결을 끊는등 중요 자원 관리 문제를 다루는 상황에서 씀
- 객체의 문자열 표현 , 67p
  - repr, str의 대한 정확한 내용 소개
  - > repr 는 eval으로 객체 생성이 다시 가능하게 문자열을 출력한다. 
- 객체 비교 및 순서 매기기 , 68p
  - `__bool__`, `__hash__`
- 타입 검사
  - 추상 기반 클래스 , 인터페이스 정의에 주로 사용
  - `__instancecheck__`,`__subclasscheck__`
- 속성 접근 69p
  - `__getattr__` 등등등
- 속성 감싸기 및 기술자(descriptor) ,70p
  - `__get__`,`__set__` 같은게 정의되었을떄의 내용인데, 설명만 봐서는 모르겠네.. 7장에 자세히 나온다함
- 🤩 순서열 및 매핑 메서드 70p
  - `__getitem__`등 순서열이나 매핑객체(내장 매핑객체는 dict 밖에 없음)을 흉내내는 객체 만들때 씀
  - > 이부분 신기한 내용이다. 
- 🌟 반복 , 72p
  - `for x in s`의 원리 나옴
- 수학연산, 72p
  - `__add__`, `__radd__`  차이 나옴 매우 신기
  - 🌟`__int__()` 같은 변환 메서드를 객체에 오버라이드 할수 있음. 이게 객체에 정의되었다고 해서 인터프리터가 자동 형변환을 해주진 않음
- 호출 가능 인터페이스 ,75p
  - `__call__` 정의 하는거 말함
  - functor나 proxy 생성에 쓰임
- 컨텍스트 관리 프로토콜
  - with문 말함
    - `__exit__` 의 경우 with문 블럭에서 나가거나 예외 발생시 모두 호출되네.
    - `__enter__` 의 경우 with문 진입시 호출되고 반환값은 as 지정자에 들어감
    - 즉 컨텍스트 관리 객체(with 문이랑 같이 쓰는..)는 위 두개가 정의 되어 있어야함
- dir, 76p
  - `dir()`은 객체 검사에 쓰이는데, 객체에  `__dir__` 를 재정의 해서 원하는 값만 노출가능
  - 이 경우에도 `__dict__` 속성을 검사하면 숨겨진 내용 모두 확인 가능

## 4장 연산자와 표현식

- 숫자에 대한 연산
  - 🤩 `5/2` py2에서는 버림 하지만, py3는 float 값으로 나옴
  - `5//2` 이건 2.5인데 여기서 소수점 밑을 버리는 연산임
- 🌟 반올림 78p
  - py3 에서는 굉장히 특이.. 알고있는 상식과 다르다.
- 순서열에 대한 연산, 80p
  - all, any, len, max, min, sum 등이 있음 
  - 🌟 +, * 연산은 의미가 다르니 주의
  - `c = x * 4`의경우 순서열 x의 내용을 4번 복사해서 list c를 만드는것 (x가 리스트인경우. 튜플이면 튜플 생김)
  - in, not in은 문자열에도 적용가능
  - min, max 는 `<` 연산자에 의해 순서가 결정되는 경우만 유효
  - sum은 모든 원소의 합인데, 항목이 숫자일 경우만 유효
  - 분할연산, 81p
    - >난해함
  - 순서열은 `<,>,==`등 로 비교가 가능. 즉, 각각 첫번쨰 요소 부터 n번쨰 까지 비교, 이떄 값이 서로 다르면 멈춤 ,38p
    - > 순서열의 값들이 같은지 비교 혹은, sub set인지 알아 볼때 쓰는듯.
    - 문자열일땐 사전 순서로 비교됨
      - py2는 바이트 문자열, 유니코드 문자열 두종류라서 여기에다 연산을 적용하면 예상과는 다를수 있음 
        - > =, + 등등 연산을 다른 type의 문자열에 쓰지 마라는것
        - > 물론 py2는 암묵적으로 형변환 하는데, py3는  typeerror를 발생시킨다.

- 고급문자열 포맷 지정 p88
  - > 이부분 꽤 기능이 많네.. format 쓰는법 인데 일단 무시
- 사전/집합/확장대입 에 대한 연산 
  - > 뻔한거
- 속성(.) 연산자
  - >  뻔한거
- 함수 호출() 연산자 92p
  - >  from functools import partial로  함수의 파라메터 일부를 고정해서 쓰는거 신기
- 변환 함수 92p
  - int, float 이런거... (문자열을 숫자 변환에도 사용)
  - `eval()`은 신기하네
  - > 앞서 나왔듯, 숫자 상수 연산은 자동 타입캐스팅이 되긴하는데, 객체에  `__int__` 오버라이드 했다고 객체를 자동 타입캐스팅 해주지 않음
  - > cpp에서는 유사한 형태면 casting 해줬음.. 이걸 뭐라 불렀는데.. 변환?
- 불리언 표시 및 진리값
  - 🌟 0이 아닌수, 비어 있지 않은 문자열, 리스트, 튜플, 사전 은 true로 간주 (false는 반대)
    - > 그렇다고 ==으로 True와 비교하면 같지 않으니까 False인데.   
    - > 만약 숫자 1인 경우는 True와 비교하면 True가 나오긴 함
- 객체 동등 및 신원
  - 🌟 `x == y` 에 대한 것. 일반적으로 값이 같은지를 확인
  - 🌟 `x is y` 메모리 상 동일 객체인지.. 
- 평가 순서
  - 즉, 우선 순위 95p
- 🌟 conditional expression
  - 복잡해서 안쓰는게 좋긴 한데, 리스트 내포에 쓰면 좋음
  ```python
  if a <= b:
    minvalue = a
  else:
    minvalue = b
  # 위 표현 대신 아래와 같이 쓸수 있다. 
  minvalue = a if a <= b else b
    
  ```

## 5장 프로그램 구조와 제어 흐름

- if문으로 함수의 두가지 버전 정의, 97p
- 🌟 for 문 
  - `for x in s` 이렇게 쓰고 s에는 리스트, 튜플, 문자열 또는
  - iterator를 정의한 객체 가능
  - 98p 참조. for문을 while로 구현한거 있음 (iterator이용)
  - for문의 x의 경우 이미 정의된게 있었다면 덮어 씌워지고, x값은 for문 밖에서도 유효
  - enumerate와 같이 써서 index를 받아서 쓸수도 있다.
- 🌟while문
  - 2개 이상의 순서열에 대해 반복을 돌때 zip을 사용한다. 100p
    - zip(s,t)의 경우 순서열 s 와 순서열 t를 합친 튜플 리스트를 만드는데
    - s와 t의 len이 다른경우는 둘중 작은거에 맞춰짐
    - 그리고 py2에서는 zip하면 큰 튜플 리스트가 하나 만들어지는데.. py3는 값을 한번에 하나씩 생성함
      - > 제너레이터?
- python은 goto문은 없다. 
- for-else
  - for가 break에 의해 중단되는 case외에는 else문이 돔
  - 언제 쓰냐?
    - 루프가 이른 시점에 종료되었을떄 flag나 조건을 설정하는 경우.. 
    - > 이런 경우 많이 있었음.. 보통은 반복문 안 if문에서 flag 세팅...  
    - > else쓰면 그럴 필요가 없다. 
- 예외
  - raise문 단독 사용시 최종적으로 생성한 예외 다시 발생 
  - > 즉 ,예외 forwarding인듯
  - 예외가 try, except에 의해 잡히지 않은경우 상위 block으로 넘어감, 거기에 try, except가 있을수 있으니.. 
    - 끝까지 잡히지 않는 `예외는 sys.excepthook()`으로 전달됨 13장에 나옴
  - 🌟103p 예외 타입 나옴
    - 그냥 `except:` 만쓰면 키보드 인터럽트등 까지 다 잡힘.
  - try - else
    - try 블록에서 예외가 안났을때 else 수행
  - finally
    - 에러 발생 유무와 상관없이 반드시 실행됨
    - 🌟 예외 발생시 제어 흐름은 except가 아닌 finally로 먼저 오고, 이후 except로 가는듯..
      - > 책 내용은 이런거 같음.. 제대로 이해한건지 확실치 않음

- 내장예외 테이블 , 105p
  - 계층형.

- 사용자 예외 정의 , 106p
  - Exception을 상속하면 됨 
  - `raise NetworkError("test")` 에서 test 문자열, 즉 parameter는 정의한 예외 class의 생성자의 param으로 전달됨
    - 이떄 사용자 예외 class의 생성자는 param을 여러개 쓸수 있음. 그 raise에서 사용할 때도 param을 여러개 넘겨야 함
  - 🌟 `__init__` 정의시 `self.args`세팅 매우 중요

- with 108p
  - with문에서 예외 발생시 `__exit__` param으로 정보가 넘어감.
    - 🤩발생된 예외가 처리 되었는지, 아닌지에 따라 `__exit__()` 의 반환이 False, True가 된다는데.. 
      - > 이부분 이해 안감 108p  
      - > 음.. 아래 코드를 통해 이해해 보면, `__exit__()`는 사용자가 정의 할수 있고, 이떄 넘어온 예외를 처리 했으면
      - > `__exit__()`함수의 return을 true로 코딩, 아니면 false로 코딩. 이렇게 false를 반환하면, with문 밖으로 error가 forwading됨.  
      - > 근데 보통의 경우 error는 None이라 return False여도 별 문제 없는듯. (None예외는 forwading될수 없어서?)
  - 컨텍스트 관리자
    - `__exit__()` 랑 `__enter__()` 구현한 class의 객체
    - `from contextlib import contextmanager` 를 이용하면 제너레이터를 컨텍스트 관리자로 만들수 있음
      - 예외 관련 부분이 중요 109p

- assert, `__debug__`
  - `if __debug__` 문을 쓸수 있는데, 이거 android if 매크로 NDEBUG랑 유사  
  - 즉 debug모드에는 위 코드가 추가 되는데, 최적 모드일땐 if문 이 아예 빠짐

## 6장 함수와 함수형 프로그래밍

이장에서 나오는것은 아래와 같다. 

- 함수형 프로그래밍
  - 함수, 유효범위 규칙, 클로저, 장식자, 생성기, 코루틴 , 기타 함수형 특징 
- 선언형 스타일 프로그래밍, 데이터 처리에 유용한것
  - 리스트 내포, 생성기 표현식 

  
- 함수
  - default param 쓸때 주의 필요
    - 아래처럼 객체가 할당되는 개념을 주의해야한다.(정의시 한번 할당됨, 사용때 할당되는게 아님) p112
    - 이걸 피할려면? default 값을 None을 주고 body에서 None일때 list를 할당받는걸로 해야함
    ```python
    def foo(x, items=[]): # 함수 정의후 실행하면 items는 list 객체가 할당됨
      items.append(x)
      return items
    foo(1)  
    foo(2)  
    foo(3)   # [1,2,3] 이 return 됨
    ```
  - 마지막 매개변수 이름 앞에 별표(*) 추가하면 함수는 여러 개의 매개변수를 받을수 있다. p112
    - > 인수가 튜플로서 전달됨. 이거 *arg 그거임, 파라메터 풀어쓰는거 그거
  - keyword argument , 113p
  - position argument, 113p
    - 위치, 키워드 인수 동시 쓸때는 무조건 위치인수를 모두 채우고 써야한다. 
    - 그리고 생략가능한 인수? 의 값들도 지정을 해줘야한다함.. 그리고 키워드 인수를 쓸수 있나봄 ( 정의말고 사용시.)
  - 아래 같은것도 있다. , 113p
  ```python
  def make_table(data,**parms) # 정의하지 않았던 키워드 인수가 모두 param dic으로 들어감
  ```
  - *args, **kwargs는 다른 함수에 대한 래퍼나 proxy를 작성하는데 주로 씀
  - 값전달 은 immutable일떄, 참조전달은 mutable 인수가 전달 될때 , 114p
    - > 값전달 처럼 보인다.. .라는 표현으로 나와있어서 책에.. 진짜 값전달인지는 모르겠음( 어짜피 immutable이라 값인지 참조인지 모르는거 아닌가..)
    - 이거때문에 sideeffect 발생하니 주의 한다. (특히 스레드 프로그래밍에서는 주의해야함)
  - return이 없으면 None객체 반환

- 유효범위 규칙
  - 함수가 실행될때 local namespace가 생성
    - 여기에는 매개변수 이름, 함수 몸체안에서 할당된 변수의 이름이 담김
  - 🌟local namespace에서 변수를 찾지 못했다면?
    - 전역 namespace -> 내장 namespace 순으로 찾고 그래도 없으면 NameError 발생
      - 함수의 전역 namespace란 `모듈`을 말한다. 
        - > 모듈은 그 이름으로 namespace가 생성되고 거긴 모듈 파일에 정의된 모든게 있다
  - global keyword
    - 함수안에서 전역 변수 접근시 사용 ( 전역변수 값 읽고 쓰기 가능)
  - python은 중첩함수 가능
    - 중첩함수는 함수안에 함수 정의 있는것
      - > 클로저에서도 쓰고, javascript에서도 있었음
    - 🌟 py2에서는 바깥쪽 함수의 변수를 안쪽 함수에서 재할당 할수 없다 , 116p
      - 즉 이경우 읽기만 가능
      - 안쪽 함수는 안쪽함수 scope랑 전역 변수만 값 재할당이 가능.
      - py3는 nonlocal keyword를 이용하면 바깥쪽 함수의 변수 재할당도 가능
    - 지역변수에 값 할당전 사용하면 UnboundError발생 , 117p
      - > 이거 나도 몇번 실수 했다.

- 🌟객체와 클로저로서 함수 , 118p
  - 클로저 : 함수를 구성하는 문장과 실행 환경을 함께 묶은것
    - > 사실상 `__closure__` 속성이 있는 함수객체를 클로저라고 보면될듯  
    - > 즉 중첩함수를 반환하면 그게 클로저, 그냥 일반 함수 객체에 실행환경이 묶인 형태(아래)는 클로저라고 말하진 않을거 같음.. 일반적으로는.. 
  - 함수를 객체로 전달할때는 함수안에 `__globals__` 속성이 있다. (중첩함수 말고..)
    - 여기는 전역 namespace의 내용이 담김 ( 본인이 쓰는 전역 변수들..등등)
  - 중첩함수를 사용할때 클로저는 내부 함수 실행을 위한 전쳬 환경을 담는다. 119p
    - > 이말은 내부함수에서 외부 함수의 local namespace 정보를 일부 가져온다는 의미 같음 (위의 globlas처럼..) -> `__closure__` 속성에 나옴
  - 클로저와 중첩함수는 lazy evaluation에 사용
  - 🌟클로저 예시 및 `__closure__` 119p
  - 일반 class 함수랑 closure로 countdown 구현한 예제 120p
    - 실제 클로저가 성능히 50%더 좋음. 
  - 클로저는 언제 사용?
    - 기존 함수에 추가 기능을 넣을때 씀 -> 데코레이터
      - > 클로저의 내부 환경 기록 특징 때문에 가능하나봄

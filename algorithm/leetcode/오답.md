# ì˜¤ë‹µ

## 621. íƒœìŠ¤í¬ ìŠ¤ì¼€ì¥´ëŸ¬

> ê·¸ë¦¬ë””.. ìš°ì„ ìˆœìœ„í í’€ì´ì¸ë°.. ì†ë„ ëª»ëŒ”ìŒ.
> ê·¼ë° ë‹µì§€ë¥¼ ë³´ë‹ˆ ë‹¤ë¥¸ ì‚¬ëŒë“¤ì€ ê·¸ëƒ¥ ìˆ˜ì‹ìœ¼ë¡œ í’€ì—ˆë„¤ --> ê·¼ë° í† í”½ì€ greedyë¡œ í‘¸ëŠ”ê²Œ ë§ê¸´í•¨. 

## 78. ë¶€ë¶„ ì§‘í•©

> ì†ë„ ëª»ëŒ. 
> ë°±íŠ¸ë˜í‚¹ ìª½ì„ ì˜ ëª»í‘¸ëŠ”ë“¯.

## 787. k ê²½ìœ ì§€ ë‚´ ê°€ì¥ ì €ë ´í•œ í•­ê³µê¶Œ

ì´ê±° ì±…ë¬¸ì œì¸ë° ë‹µì´ ì˜ëª»ë¨. ê·¸ëŸ¼ì—ë„ leetcode ë‹µì„ ë´¤ëŠ”ë° ì´í•´ê°€ ì•ˆë˜ë„¤..
> í•´ë‹µ í•´ì„¤ ë‹¤ì‹œ ì ì—ˆìœ¼ë‹ˆ 787ë¬¸ì œ í™•ì¸

```python
    # visit(dist)ë¥¼ ë§Œë“¤ì–´ì„œ ë°©ë¬¸í•œê³³ì€ ë‹¤ì‹œ ë°©ë¬¸í•˜ì§€ ì•Šê²Œ í•´ì•¼í•˜ëŠ”ë°.
    # ê·¸ë ‡ê²Œ í•˜ê¸° ìœ„í•´ ì•„ë˜ì™€ ê°™ì´ í•˜ë©´ ë‹µì´ ì•ˆë‚˜ì˜´.
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:

        graph = defaultdict(list)
        # ê·¸ë˜í”„ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ êµ¬ì„±
        for u, v, w in flights:
            graph[u].append((v, w))

        # í ë³€ìˆ˜: [(ê°€ê²©, ì •ì , ë‚¨ì€ ê°€ëŠ¥ ê²½ìœ ì§€ ìˆ˜)]
        Q = [(0, src, K)]

        visit = []

        # ìš°ì„  ìˆœìœ„ í ìµœì†Œê°’ ê¸°ì¤€ìœ¼ë¡œ ë„ì°©ì ê¹Œì§€ ìµœì†Œ ë¹„ìš© íŒë³„
        while Q:
            price, node, k = heapq.heappop(Q)
            if node == dst:
                return price

            if node in visit: # ê·¼ë° ì›ë˜ ì´ë ‡ê²Œ í•´ë„ ë‹µì´ ë‚˜ì™€ì•¼ í•˜ì§€ ì•Šë‚˜? -> kì˜ ì¡°ê±´ ë•Œë¬¸ì— ì—¬ê¸°ì„œëŠ” ì´ë ‡ê²Œ í•˜ë©´ì•ˆë¨
                continue

            if k >= 0:
                visit.append(node)
                for v, w in graph[node]:
                    alt = price + w
                    heapq.heappush(Q, (alt, v, k - 1))
        return -1

```

## 189. Rotate Array ë¬¸ì œ ì‹¤íŒ¨

- <https://leetcode.com/problems/rotate-array/discuss/1730142/JavaC%2B%2BPython-A-very-very-well-detailed-explanation>
- ì‹¤íŒ¨ ì›ì¸
  - two pointerì— ë„ˆë¬´ ëª°ì…í•¨
  - ê·œì¹™ì„ ì†ìœ¼ë¡œ ê·¸ë ¤ë´ì•¼ í–ˆì„ë“¯.
  - ê·¸ë¦¬ê³ , ë¯¸ë””ì—„ ë¬¸ì œë¥¼ ë„ˆë¬´ ì˜¤ë˜ ìƒê°í•¨.
  - ê·¸ë¦¬ê³ , í•­ìƒ ì½”ë„ˆ ì¼€ì´ìŠ¤ ê³ ë ¤ í•´ì•¼í•¨ ğŸ‘
  - > ì‚¬ì‹¤ ìœ„ rotateë¥¼ ìƒê°í•´ ë‚¼ìˆ˜ ìˆì—ˆì„ì§€ëŠ”.. ë¯¸ì§€ìˆ˜.

## 283. Move Zeroes

- íˆ¬ í¬ì¸í„° slow, fastë¥¼ ì´ìš©í•˜ëŠ” ë°©ì‹
- > íˆ¬ í¬ì¸í„° ì „ëµë“¤ì„ ìˆ™ì§€í•˜ì§€ëª»í•¨.
- > ì¸ì ‘ ê°’ë“¤ êµì²´ë§Œ ìƒê°í•¨..( ë²„ë¸”ì •ë ¬ ìƒê°ë§Œ í•¨. )

## 332. ì¼ì • ì¬êµ¬ì„±

  ì´ê±° dfsì¸ë° ì•„ë˜ ì£¼ì„ í™•ì¸

  ```python
      def findItinerary(self, tickets: List[List[str]]) -> List[str]:

          result = []
          graph = defaultdict(deque)
          for v1, v2 in sorted((tickets)):
              graph[v1].append(v2)

          def dfs(vertex: str):
              while graph[vertex]:
                  dfs(graph[vertex].popleft())
              result.append(vertex) # appendë¥¼ while ìœ„ì— ì˜¬ë¦¬ë©´ ì•ˆí’€ë¦¼. ì¦‰ ì´ë¬¸ì—ëŠ” ë…¸ë“œë¥¼ ì«™í¼ì¹œí›„ ë°±íŠ¸ë˜í‚¹ í•´ê°€ëŠ”ê²ƒ!

          dfs("JFK")
          return result[::-1]

  ```

## 116. Populating Next Right Pointers in Each Node

## 542. 01 Matrix ğŸ‘

- bfs í’€ì´ë²•ì´ ì¤‘ìš”
  - <https://leetcode.com/problems/01-matrix/discuss/1369741/C%2B%2BJavaPython-BFS-DP-solutions-with-Picture-Clean-and-Concise-O(1)-Space>

- ì˜ê²¬
  - ì´ê±° dfs ì•„ë‹˜ bfs
  - bfsë¡œ matrix í’€ì´ë²• ìˆ™ì§€ ì¤‘ìš”
  - ì´ê±° DP í’€ì´ë²•ë„ ì¤‘ìš”.
  - í•˜ì§€ë§Œ bfsë¡œ í‘¸ëŠ”ë° ë¬¸ì œì˜ íŠ¹ì§• ì¤‘ìš”!

- í•´ë‹µ bfx

    ```python
        #
        def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
            # bfsë¡œ ì§„í–‰.
            # 1) íì— ì§„ì…ì  ì¶”ê°€
            q = deque()
            for i in range(len(mat)):
                for j in range(len(mat[0])):
                    if mat[i][j] == 0:
                        q.append((i, j))
                    else:
                        mat[i][j] = -1

            # 2) ë£¨í”„ ëŒë©´ì„œ ì§„í–‰í•„ìš”, tric (ì•ˆê°„ê³³ì„ -1 ë§ˆí‚¹, ì›ë˜ëŠ” visit list,dic í™œìš©..)
            #    ê°’ ì„¸íŒ….
            loop = [(0, 1), (0, -1), (1, 0), (-1, 0)] # ì´ë°©ì‹ ì¢‹ìŒ, ì¸ë¼ì¸ ê°€ëŠ¥
            while q:
                i, j = q.popleft()
                for r, c in loop:
                    ir, jc = i + r, j + c
                    if ir < 0 or ir >= len(mat) or jc < 0 or jc >= len(mat[0]) or mat[ir][jc] != -1:
                        continue
                    mat[ir][jc] = mat[i][j] + 1
                    q.append((ir,jc))
            return mat
    ```

## 994. Rotting Oranges ğŸ‘

- ë¬¸ì œëŠ” ë³´ë©´ BFS ê·¸ë˜í”„ ìˆœíšŒì„. 

- ì˜ê²¬
  - (1,1)ì—ì„œ ì‹œì‘í•´ì„œ í•œë²ˆ ë£¨í”„ ëŒê³  ê°’ì„ matrixì— ì‘ì„±í–ˆë‹¤ë©´ ì´ˆê¸°í™”ë¥¼ ì–´ë–»ê²Œ í•´ì•¼í•˜ëŠ”ì§€? 542ë‹µë“¤ì¢€ í™•ì¸.
    - > bfsë¡œ í’€ì´ë¥¼ í•˜ëŠ”ê²½ìš° ì´ˆê¸°í™”ë¼ëŠ” ë‹¨ê³„ í•„ìš” ì—†ëŠ”ë“¯. ì™œëƒë©´ ì¼ë°˜ì ìœ¼ë¡œ visit íê°€ ìˆìŒ. ì´ê²ƒë§Œ ë‹¤ì‹œ ë§Œë“¤ë©´ë¨.
    - > 542ëŠ” í•˜ì§€ë§Œ ì´ë ‡ê²Œ í’€ì§€ëŠ” ì•ŠìŒ
    - > ì´ê±° ëŠ” ì•„ë˜ íŠ¸ë¦­ 1ì´ ë§¤ìš° ì¤‘ìš”!
  - coordinate ë§ì…ˆë°©ë²•ì€ 994, 542ëŒ€ë¡œ í•˜ëŠ”ê²Œ ì¢‹ì„ë“¯

- ì•„ë˜ê°€ í•´ë‹µì¸í…Œ íŠ¸ë¦­ì´ ëª‡ê°€ì§€ ìˆìŒ

```python
    def orangesRotting(self, grid: List[List[int]]) -> int:
        visit, curr = set(), deque()

         # find all fresh and rotten oranges
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    visit.add((i, j)) # (íŠ¸ë¦­2) ë°©ë¬¸í•´ì•¼ í•˜ëŠ” ìœ„ì¹˜ë¥¼ ì´ë ‡ê²Œ setì— ë„£ì–´ë‘ . 
                elif grid[i][j] == 2:
                    curr.append((i, j))
        
        result = 0

        while visit and curr:

            # BFS iteration
            for _ in range(len(curr)): # (íŠ¸ë¦­1) len(curr) ë¡œ ë§Œë“¤ì–´ì§„ rangeëŠ” ê³ ì •ëœ ê°’ì„. curr ë³€ê²½ëœë‹¤ê³  ë³€í•˜ì§€ ì•ŠìŒ. ğŸ‘
                i, j = curr.popleft()  # obtain recent rotten orange
                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): # (íŠ¸ë¦­3) ë‹¤ìŒ ì§„ì… ì¢Œí‘œë¥¼ ì´ë ‡ê²Œ ë§Œë“¬
                    if coord in visit:  # check if adjacent orange is fresh
                        visit.remove(coord)
                        curr.append(coord)
            result += 1

        # check if fresh oranges remain and return accordingly
        # ì¡°ê±´
        return -1 if visit else result

```

- ë‚´ë‹µ

    ```python
        def orangesRotting(self, grid: List[List[int]]) -> int:
            # ì´ˆê¸° ì§„ì… ìœ„ì¹˜ ì¶”ê°€
            ## targetsëŠ” ë°©ë¬¸í•´ì•¼ í•˜ëŠ” ìœ„ì¹˜
            targets, start = set(), deque()
            m, n = len(grid), len(grid[0])
            for i in range(m):
                for j in range(n):
                    if grid[i][j] == 2:
                        start.append((i, j))
                    elif grid[i][j] == 1:
                        targets.add((i, j))
            # bfs
            ## vist ë‘ëŠ”ê²Œ ë‚˜ìŒ
            ## ë§ˆì§€ë§‰ ë‚¨ì€ ê²ƒì€ visitê°€ ì—†ìŒ. ì¦‰ ë‹¨ê³„ë¥¼ ì§„í–‰í•  í•„ìš”ê°€ ì—†ì–´ì„œ and targets í•„ìš”
            result = 0
            while start and targets:
                for _ in range(len(start)):
                    i, j = start.popleft()
                    for r, c in {(0, 1), (0, -1), (1, 0), (-1, 0)}:
                        ir, jc = i + r, j + c
                        # if ir < 0 or ir >= m or jc < 0 or jc >= n or (ir, jc) not in targets: ì´ëŸ° ì¡°ê±´ì€ BFSì—ì„œëŠ” í•„ìš”ê°€ ì—†ìŒ ğŸ‘
                        #     continue
                        if (ir, jc) in targets: # ë‹¨ ì´ ì¡°ê±´ì€ í•„ìš” ( ì•„ì§ ë°©ë¬¸ ì•ˆí•œê³³ì¸ì§€ check)
                            start.append((ir, jc))
                            targets.remove((ir, jc))
                result += 1

            return -1 if targets else result

    ```
 
### 120. Triangle

- ì¤‘ìš” 
  - ì¡°ê±´ ê²€ì‚¬ë¥¼ `if memo[level][index] :` ì´ë ‡ê²Œ í•´ì„œëŠ” ì•ˆë¨
  - ì™œëƒë©´ `memo[level][index]` ë¥¼ Noneìœ¼ë¡œ ì„¸íŒ…í–ˆëŠ”ë°, ê°’ì´ 0ì´ ë“¤ì–´ì˜¤ëŠ” ê²½ìš°   `if memo[level][index] :`  ì´ê±¸ ì•ˆíƒ ğŸ‘

```python
    def minimumTotal(self, triangle: List[List[int]]) -> int:

        memo = [[None] * len(n) for n in triangle]
        max_level = len(triangle)-1

        def min_path(index: int, level: int) -> int:
            if level == max_level:
                return triangle[level][index]
            if memo[level][index] != None: # if memo[level][index] : ì´ë ‡ê²Œ ì¡°ê±´ ê²€ì‚¬ í•˜ë©´ ì•ˆë¨
                return memo[level][index]

            memo[level][index] = triangle[level][index] + min(min_path(index, level + 1), min_path(index + 1, level + 1))
            return memo[level][index]

        return min_path(0, 0)

```
# ì˜¤ë‹µ

## 787. k ê²½ìœ ì§€ ë‚´ ê°€ì¥ ì €ë ´í•œ í•­ê³µê¶Œ

ì´ê±° ì±…ë¬¸ì œì¸ë° ë‹µì´ ì˜ëª»ë¨. ê·¸ëŸ¼ì—ë„ leetcode ë‹µì„ ë´¤ëŠ”ë° ì´í•´ê°€ ì•ˆë˜ë„¤..
> í•´ë‹µ í•´ì„¤ ë‹¤ì‹œ ì ì—ˆìœ¼ë‹ˆ 787ë¬¸ì œ í™•ì¸

```python
    # visit(dist)ë¥¼ ë§Œë“¤ì–´ì„œ ë°©ë¬¸í•œê³³ì€ ë‹¤ì‹œ ë°©ë¬¸í•˜ì§€ ì•Šê²Œ í•´ì•¼í•˜ëŠ”ë°.
    # ê·¸ë ‡ê²Œ í•˜ê¸° ìœ„í•´ ì•„ë˜ì™€ ê°™ì´ í•˜ë©´ ë‹µì´ ì•ˆë‚˜ì˜´.
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:

        graph = defaultdict(list)
        # ê·¸ë˜í”„ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ êµ¬ì„±
        for u, v, w in flights:
            graph[u].append((v, w))

        # í ë³€ìˆ˜: [(ê°€ê²©, ì •ì , ë‚¨ì€ ê°€ëŠ¥ ê²½ìœ ì§€ ìˆ˜)]
        Q = [(0, src, K)]

        visit = []

        # ìš°ì„  ìˆœìœ„ í ìµœì†Œê°’ ê¸°ì¤€ìœ¼ë¡œ ë„ì°©ì ê¹Œì§€ ìµœì†Œ ë¹„ìš© íŒë³„
        while Q:
            price, node, k = heapq.heappop(Q)
            if node == dst:
                return price

            if node in visit: # ê·¼ë° ì›ë˜ ì´ë ‡ê²Œ í•´ë„ ë‹µì´ ë‚˜ì™€ì•¼ í•˜ì§€ ì•Šë‚˜? -> kì˜ ì¡°ê±´ ë•Œë¬¸ì— ì—¬ê¸°ì„œëŠ” ì´ë ‡ê²Œ í•˜ë©´ì•ˆë¨
                continue

            if k >= 0:
                visit.append(node)
                for v, w in graph[node]:
                    alt = price + w
                    heapq.heappush(Q, (alt, v, k - 1))
        return -1

```

## 189. Rotate Array ë¬¸ì œ ì‹¤íŒ¨

- <https://leetcode.com/problems/rotate-array/discuss/1730142/JavaC%2B%2BPython-A-very-very-well-detailed-explanation>
- ì‹¤íŒ¨ ì›ì¸
  - two pointerì— ë„ˆë¬´ ëª°ì…í•¨
  - ê·œì¹™ì„ ì†ìœ¼ë¡œ ê·¸ë ¤ë´ì•¼ í–ˆì„ë“¯.
  - ê·¸ë¦¬ê³ , ë¯¸ë””ì—„ ë¬¸ì œë¥¼ ë„ˆë¬´ ì˜¤ë˜ ìƒê°í•¨.
  - ê·¸ë¦¬ê³ , í•­ìƒ ì½”ë„ˆ ì¼€ì´ìŠ¤ ê³ ë ¤ í•´ì•¼í•¨ ğŸ‘
  - > ì‚¬ì‹¤ ìœ„ rotateë¥¼ ìƒê°í•´ ë‚¼ìˆ˜ ìˆì—ˆì„ì§€ëŠ”.. ë¯¸ì§€ìˆ˜.

## 283. Move Zeroes

- íˆ¬ í¬ì¸í„° slow, fastë¥¼ ì´ìš©í•˜ëŠ” ë°©ì‹
- > íˆ¬ í¬ì¸í„° ì „ëµë“¤ì„ ìˆ™ì§€í•˜ì§€ëª»í•¨.
- > ì¸ì ‘ ê°’ë“¤ êµì²´ë§Œ ìƒê°í•¨..( ë²„ë¸”ì •ë ¬ ìƒê°ë§Œ í•¨. )

## 332. ì¼ì • ì¬êµ¬ì„±

  ì´ê±° dfsì¸ë° ì•„ë˜ ì£¼ì„ í™•ì¸

  ```python
      def findItinerary(self, tickets: List[List[str]]) -> List[str]:

          result = []
          graph = defaultdict(deque)
          for v1, v2 in sorted((tickets)):
              graph[v1].append(v2)

          def dfs(vertex: str):
              while graph[vertex]:
                  dfs(graph[vertex].popleft())
              result.append(vertex) # appendë¥¼ while ìœ„ì— ì˜¬ë¦¬ë©´ ì•ˆí’€ë¦¼. ì¦‰ ì´ë¬¸ì—ëŠ” ë…¸ë“œë¥¼ ì«™í¼ì¹œí›„ ë°±íŠ¸ë˜í‚¹ í•´ê°€ëŠ”ê²ƒ!

          dfs("JFK")
          return result[::-1]

  ```

## 116. Populating Next Right Pointers in Each Node

## 542. 01 Matrix ğŸ‘

> ì‹¤íŒ¨
> ì´ê±° dfs ì•„ë‹˜ bfsì„.
> bfs tipì´ ìˆë„¤. íì— í•´ë‹¹ ë‹¨ê³„ nodeê°€ ë“¤ì–´ê°€ì„œ 0ì´ ë‚˜ì™€ì„œ ì²˜ë¦¬ë˜ë©´ ì´ê²Œ ìµœì†Œ distanceì„
> bfs íŠ¹ì„± ë•Œë¬¸ì— ë‹¤ìŒ ë‹¨ê³„ë¡œ ë“¤ì–´ê°€ë©´ dist + 1ì´ë‹ˆê¹Œ.. ==> ëŒ€ë¶€ë¶„ì˜ í’€ì´ê°€ ì´íŠ¹ì§•ì„ ì´ìš©
> DP í’€ì´ë„ ìˆìŒ -> ì˜¤..

## 994. Rotting Oranges ğŸ‘

> ì‹¤íŒ¨..
> ì˜ˆë¥¼ë“¤ì–´
> (1,1)ì—ì„œ ì‹œì‘í•´ì„œ í•œë²ˆ ë£¨í”„ ëŒê³  ê°’ì„ matrixì— ì‘ì„±í–ˆë‹¤ë©´ ì´ˆê¸°í™”ë¥¼ ì–´ë–»ê²Œ í•´ì•¼í•˜ëŠ”ì§€? 542ë‹µë“¤ì¢€ í™•ì¸.
> coordinate ë§ì…ˆë°©ë²•ì€ 994, 542ëŒ€ë¡œ í•˜ëŠ”ê²Œ ì¢‹ì„ë“œ.

- ì•„ë˜ê°€ í•´ë‹µì¸í…Œ íŠ¸ë¦­ì´ ëª‡ê°€ì§€ ìˆìŒ 

```python
    def orangesRotting(self, grid: List[List[int]]) -> int:
        visit, curr = set(), deque()

         # find all fresh and rotten oranges
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    visit.add((i, j)) # (íŠ¸ë¦­2) ë°©ë¬¸í•´ì•¼ í•˜ëŠ” ìœ„ì¹˜ë¥¼ ì´ë ‡ê²Œ setì— ë„£ì–´ë‘ . 
                elif grid[i][j] == 2:
                    curr.append((i, j))
        
        result = 0

        while visit and curr:

            # BFS iteration
            for _ in range(len(curr)): # (íŠ¸ë¦­1) len(curr) ë¡œ ë§Œë“¤ì–´ì§„ rangeëŠ” ê³ ì •ëœ ê°’ì„. curr ë³€ê²½ëœë‹¤ê³  ë³€í•˜ì§€ ì•ŠìŒ.
                i, j = curr.popleft()  # obtain recent rotten orange
                for coord in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)): # (íŠ¸ë¦­3) ë‹¤ìŒ ì§„ì… ì¢Œí‘œë¥¼ ì´ë ‡ê²Œ ë§Œë“¬
                    if coord in visit:  # check if adjacent orange is fresh
                        visit.remove(coord)
                        curr.append(coord)
            result += 1

        # check if fresh oranges remain and return accordingly
        # ì¡°ê±´
        return -1 if visit else result

```

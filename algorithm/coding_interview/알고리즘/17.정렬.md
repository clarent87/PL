# 정렬

## 개요

- 버블 정렬
  - O(n^2) 알고리즘
  - 비효율적이고 가장 느림

- 병합 정렬
  - 분할 정복 알고리즘
  - 퀵 정렬보다 느림
  - stable sort (안전 정렬)
    - 그래서 아직도 상용 라이브러리에 많이 쓰임
  - O(n log n) 성능임 항상
  - > 22장에서 설명한다함

- 퀵 정렬
  - 피벗을 기준으로 좌우를 나눔
    - 피벗보다 작으면 왼쪽, 크면 오른쪽..
  - Partition-Exchange sort 라고도 함.
  - 분할 정복 알고리즘
  - 여러가지 버전이 있음
    - 여기서는 N.로무토가 구현한 파티션 계획 (partition scheme)을 살펴봄
    - > 로무토 파티션
  - 로무토 파티션
    - 항상 맨 오른쪽의 피벗을 택하는 단순 방식
    - 간결하고 이해하기 쉬워서 퀵 정렬 소개에 항상 맨 처음 나옴
  - 최악의 경우 O(n^2)
    - 정렬된 채로 입력이 들어오면. 피봇이 항상 마지막 값
    - 즉 파티셔닝이 이루어 지지 않음.
      - > 근데 파티셔닝이 이루어져도 어짜피 비교는 n번씩 진행되는거 같긴한데..
      - > 대신 단계가 줄어드나봄. 
      - > 즉 정렬된 입력값 7개 이면 7*7 번 비교 진행
      - > 비 정렬 입력값이 7개 면 7번씩 3번 비교 일듯
    - > 이해가 살짝 어렵네
  - 안정 정렬이 아님

    ```python

    def quicksort(A, lo, hi):
        # 투 포인터 전략임
        def partition(lo, hi):
            pivot = A[hi]
            left = lo
            for right in range(lo, hi):
                if A[right] < pivot: # right가 피봇보다 작은경우 left랑 교체 
                                     # ( left쪽은 항상 피봇보다 작은값 둠) 
                    A[left], A[right] = A[right], A[left]
                    left += 1
            A[left], A[hi] = A[hi], A[left] # 마지막으로 피봇위치 left 위치로 이동
                                            # 이러면 left쪽으로는 피봇보다 작은값, right는 큰값이 옴
            return left

        if lo < hi:
            pivot = partition(lo, hi) # 여기서 pivot은 인덱스
            quicksort(A, lo, pivot - 1)
            quicksort(A, pivot + 1, hi)


    A = [38, 27, 43, 3, 9, 82, 10]
    quicksort(A, 0, len(A) - 1)
    print(A)

    ```

- 안정 정렬 vs 불안정 정렬
  - stable sort 알고리즘은 중복된 값을 입력 순서와 동일하게 정렬
  - 예를 들면
    - 시간, 지역이 있는 택배로그가 있다고 치자
    - 이떄 시간순으로 택배로그를 정렬한뒤
    - 다시 A알고리즘을 통해 지역순으로 다시 정렬한경우
    - 처음 정렬했던 시간순서가, 지역으로 정렬했을때 유지 되었다면
      - > 즉 지역별로도 시간순서로 나열됨
    - 이게 안정 정렬
  - 안정 정렬
    - 버블, 병합
    - 팀소트
      - 병합 정렬 + 삽입 정렬을 휴리스틱하게 조합한 알고리즘
  - 불안정 정렬
    - 퀵


## 148. 리스트 정렬

- 문제  
  - 연결 리스트를 O( n log n)에 정렬하라

- 풀이1. 병합정렬

- 풀이2. 퀵정렬
  - > 가능은 한데, 퀵정렬 튜닝해야함. 이 책의 범위를 넘어섬
  - > 기본적으로 연결리스트는 로무토 같은 고정된 피봇 퀵 정렬만가능..
  - > 피봇을 랜덤하게 뽑을수 있어야. 정렬된 input도 대응을 할수 있나봄.

- 풀이3. 내장 함수를 이용하는 실용적인 방법

## 56. 구간 병합

## 147. 삽입 정렬 리스트

## 179. 가장 큰 수

## 242. 유효한 애너 그램

## 75. 색 정렬

## 973. 원점에 k번째로 가까운 점
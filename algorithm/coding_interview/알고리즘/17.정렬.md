# ì •ë ¬

## ê°œìš”

- ë²„ë¸” ì •ë ¬
  - O(n^2) ì•Œê³ ë¦¬ì¦˜
  - ë¹„íš¨ìœ¨ì ì´ê³  ê°€ì¥ ëŠë¦¼

- ë³‘í•© ì •ë ¬
  - ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜
  - í€µ ì •ë ¬ë³´ë‹¤ ëŠë¦¼
  - stable sort (ì•ˆì „ ì •ë ¬)
    - ê·¸ë˜ì„œ ì•„ì§ë„ ìƒìš© ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ë§ì´ ì“°ì„
  - O(n log n) ì„±ëŠ¥ì„ í•­ìƒ
    - ì™œ ì´ì„±ëŠ¥ì¸ì§€ ì˜ ìƒê°í•´ë³´ë©´
    - ë²„ë¸”ì€ Aìš”ì†Œë¥¼ ë‚˜ë¨¸ì§€ Nê°œì˜ ìš”ì†Œì™€ ë¹„êµí•˜ëŠ”ë°
    - ë³‘í•©ì—ì„œëŠ” Aìš”ì†Œì™€ ë¹„êµë˜ëŠ” ìš”ì†Œê°€ ë‹¨ê³„ ë‹¤í•©ì³ë„ Nê°œê°€ ë˜ì§€ëŠ” ì•ŠìŒ. ì´ log n.. => ê·¸ë¦¼ê·¸ë ¤ì„œ ì˜ ìƒê°í•´ë³´ë©´ ì•
  - > 22ì¥ì—ì„œ ì„¤ëª…í•œë‹¤í•¨

- í€µ ì •ë ¬
  - í”¼ë²—ì„ ê¸°ì¤€ìœ¼ë¡œ ì¢Œìš°ë¥¼ ë‚˜ëˆ”
    - í”¼ë²—ë³´ë‹¤ ì‘ìœ¼ë©´ ì™¼ìª½, í¬ë©´ ì˜¤ë¥¸ìª½..
  - Partition-Exchange sort ë¼ê³ ë„ í•¨.
  - ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜
  - ì—¬ëŸ¬ê°€ì§€ ë²„ì „ì´ ìˆìŒ
    - ì—¬ê¸°ì„œëŠ” N.ë¡œë¬´í† ê°€ êµ¬í˜„í•œ íŒŒí‹°ì…˜ ê³„íš (partition scheme)ì„ ì‚´í´ë´„
    - > ë¡œë¬´í†  íŒŒí‹°ì…˜
  - ë¡œë¬´í†  íŒŒí‹°ì…˜
    - í•­ìƒ ë§¨ ì˜¤ë¥¸ìª½ì˜ í”¼ë²—ì„ íƒí•˜ëŠ” ë‹¨ìˆœ ë°©ì‹
    - ê°„ê²°í•˜ê³  ì´í•´í•˜ê¸° ì‰¬ì›Œì„œ í€µ ì •ë ¬ ì†Œê°œì— í•­ìƒ ë§¨ ì²˜ìŒ ë‚˜ì˜´
  - ìµœì•…ì˜ ê²½ìš° O(n^2)
    - ì •ë ¬ëœ ì±„ë¡œ ì…ë ¥ì´ ë“¤ì–´ì˜¤ë©´. í”¼ë´‡ì´ í•­ìƒ ë§ˆì§€ë§‰ ê°’
    - ì¦‰ íŒŒí‹°ì…”ë‹ì´ ì´ë£¨ì–´ ì§€ì§€ ì•ŠìŒ.
      - > ê·¼ë° íŒŒí‹°ì…”ë‹ì´ ì´ë£¨ì–´ì ¸ë„ ì–´ì§œí”¼ ë¹„êµëŠ” në²ˆì”© ì§„í–‰ë˜ëŠ”ê±° ê°™ê¸´í•œë°..
      - > ëŒ€ì‹  ë‹¨ê³„ê°€ ì¤„ì–´ë“œë‚˜ë´„. 
      - > ì¦‰ ì •ë ¬ëœ ì…ë ¥ê°’ 7ê°œ ì´ë©´ 7*7 ë²ˆ ë¹„êµ ì§„í–‰
      - > ë¹„ ì •ë ¬ ì…ë ¥ê°’ì´ 7ê°œ ë©´ 7ë²ˆì”© 3ë²ˆ ë¹„êµ ì¼ë“¯
    - > ì´í•´ê°€ ì‚´ì§ ì–´ë µë„¤
  - ì•ˆì • ì •ë ¬ì´ ì•„ë‹˜

    ```python

    def quicksort(A, lo, hi):
        # íˆ¬ í¬ì¸í„° ì „ëµì„
        def partition(lo, hi):
            pivot = A[hi]
            left = lo
            for right in range(lo, hi):
                if A[right] < pivot: # rightê°€ í”¼ë´‡ë³´ë‹¤ ì‘ì€ê²½ìš° leftë‘ êµì²´ 
                                     # ( leftìª½ì€ í•­ìƒ í”¼ë´‡ë³´ë‹¤ ì‘ì€ê°’ ë‘ ) 
                    A[left], A[right] = A[right], A[left]
                    left += 1
            A[left], A[hi] = A[hi], A[left] # ë§ˆì§€ë§‰ìœ¼ë¡œ í”¼ë´‡ìœ„ì¹˜ left ìœ„ì¹˜ë¡œ ì´ë™
                                            # ì´ëŸ¬ë©´ leftìª½ìœ¼ë¡œëŠ” í”¼ë´‡ë³´ë‹¤ ì‘ì€ê°’, rightëŠ” í°ê°’ì´ ì˜´
            return left

        if lo < hi:
            pivot = partition(lo, hi) # ì—¬ê¸°ì„œ pivotì€ ì¸ë±ìŠ¤
            quicksort(A, lo, pivot - 1)
            quicksort(A, pivot + 1, hi)


    A = [38, 27, 43, 3, 9, 82, 10]
    quicksort(A, 0, len(A) - 1)
    print(A)

    ```

- ì•ˆì • ì •ë ¬ vs ë¶ˆì•ˆì • ì •ë ¬
  - stable sort ì•Œê³ ë¦¬ì¦˜ì€ ì¤‘ë³µëœ ê°’ì„ ì…ë ¥ ìˆœì„œì™€ ë™ì¼í•˜ê²Œ ì •ë ¬
  - ì˜ˆë¥¼ ë“¤ë©´
    - ì‹œê°„, ì§€ì—­ì´ ìˆëŠ” íƒë°°ë¡œê·¸ê°€ ìˆë‹¤ê³  ì¹˜ì
    - ì´ë–„ ì‹œê°„ìˆœìœ¼ë¡œ íƒë°°ë¡œê·¸ë¥¼ ì •ë ¬í•œë’¤
    - ë‹¤ì‹œ Aì•Œê³ ë¦¬ì¦˜ì„ í†µí•´ ì§€ì—­ìˆœìœ¼ë¡œ ë‹¤ì‹œ ì •ë ¬í•œê²½ìš°
    - ì²˜ìŒ ì •ë ¬í–ˆë˜ ì‹œê°„ìˆœì„œê°€, ì§€ì—­ìœ¼ë¡œ ì •ë ¬í–ˆì„ë•Œ ìœ ì§€ ë˜ì—ˆë‹¤ë©´
      - > ì¦‰ ì§€ì—­ë³„ë¡œë„ ì‹œê°„ìˆœì„œë¡œ ë‚˜ì—´ë¨
    - ì´ê²Œ ì•ˆì • ì •ë ¬
  - ì•ˆì • ì •ë ¬
    - ë²„ë¸”, ë³‘í•©
    - íŒ€ì†ŒíŠ¸
      - ë³‘í•© ì •ë ¬ + ì‚½ì… ì •ë ¬ì„ íœ´ë¦¬ìŠ¤í‹±í•˜ê²Œ ì¡°í•©í•œ ì•Œê³ ë¦¬ì¦˜
  - ë¶ˆì•ˆì • ì •ë ¬
    - í€µ


## 148. ë¦¬ìŠ¤íŠ¸ ì •ë ¬

- ë¬¸ì œ  
  - ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ O( n log n)ì— ì •ë ¬í•˜ë¼

- í’€ì´1. ë³‘í•©ì •ë ¬
  - > ì—°ê²°ë¦¬ìŠ¤íŠ¸ëŠ” ì „ì²´ ê¸¸ì´ë¥¼ ì•Œìˆ˜ ì—†ê¸° ë•Œë¬¸ì—, ì¤‘ê°„ì„ ë‚˜ëˆ„ê¸° ìœ„í•´ ëŸ°ë„ˆ ê¸°ë²•ì„ ì‚¬ìš© ğŸ‘
  - ë³‘í•©ì •ë ¬ì€ ë‚˜ëˆ„ëŠ” ë¡œì§, í•©ì¹˜ëŠ” ë¡œì§ì´ ìˆë„¤.. ì•„ë˜ëŠ” ë‘ê°œ ëª¨ë‘ ì¬ê·€ì„

  ```python

  class ListNode:
      def __init__(self, x):
          self.val = x
          self.next = None


  class Solution:
      # ë‘ ì •ë ¬ ë¦¬ìŠ¤íŠ¸ ë³‘í•©
      # 8ì¥ ë‘ ì •ë ¬ ë¦¬ìŠ¤íŠ¸ ë³‘í•© ë¬¸ì œì™€ ë™ì¼í•œ methodì¨ë„ ëœë‹¤í•¨.
      # ì´ ë³‘í•© í•¨ìˆ˜ëŠ” ì™¸ì›Œë‘ëŠ”ê²Œ ì¢‹ì„ë“¯ ğŸ‘
      # ì´ê²Œ ì‰¬ìš´ í¸ì´ë„¤.. 8ì¥ ê·¸ê±° ë³´ë‹¤
      def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
          if l1 and l2:
              if l1.val > l2.val:
                  l1, l2 = l2, l1 # ì‘ì€ ìª½ì´ ì™¼ìª½ìœ¼ë¡œ ì˜¤ê²Œ..
              l1.next = self.mergeTwoLists(l1.next, l2)

          return l1 or l2 # l1ì´ Noneì´ë©´ l2ê°€ ë°˜í™˜ë¨. l1ì— ê°’ì´ ìˆìœ¼ë©´ l1 ë°˜í™˜

      def sortList(self, head: ListNode) -> ListNode:
          if not (head and head.next):
              return head

          # ëŸ°ë„ˆ ê¸°ë²• í™œìš©
          half, slow, fast = None, head, head
          while fast and fast.next:
              half, slow, fast = slow, slow.next, fast.next.next
          half.next = None

          # ë¶„í•  ì¬ê·€ í˜¸ì¶œ
          l1 = self.sortList(head)
          l2 = self.sortList(slow)

          return self.mergeTwoLists(l1, l2)

  ```

- í’€ì´2. í€µì •ë ¬
  - > ê°€ëŠ¥ì€ í•œë°, í€µì •ë ¬ íŠœë‹í•´ì•¼í•¨. ì´ ì±…ì˜ ë²”ìœ„ë¥¼ ë„˜ì–´ì„¬
  - > ê¸°ë³¸ì ìœ¼ë¡œ ì—°ê²°ë¦¬ìŠ¤íŠ¸ëŠ” ë¡œë¬´í†  ê°™ì€ ê³ ì •ëœ í”¼ë´‡ í€µ ì •ë ¬ë§Œê°€ëŠ¥..
  - > í”¼ë´‡ì„ ëœë¤í•˜ê²Œ ë½‘ì„ìˆ˜ ìˆì–´ì•¼. ì •ë ¬ëœ inputë„ ëŒ€ì‘ì„ í• ìˆ˜ ìˆë‚˜ë´„.

- í’€ì´3. ë‚´ì¥ í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ëŠ” ì‹¤ìš©ì ì¸ ë°©ë²•
  - í™”ì´íŠ¸ ë³´ë“œì— í’€ë• ë‹¹ì—°, ì´ë ‡ê²Œ í•˜ë©´ ì•ˆë¨
  - ê·¼ë° ì˜¨ë¼ì¸ ì½”í…Œì—ì„  ì´ë°©ë²• ê°•ì¶”
  - Cë¡œ êµ¬í˜„ëœ íŒ€ì†ŒíŠ¸ë¥¼ ì´ìš©í•˜ê¸° ë•Œë¬¸ì— ê°€ì¥ ë¹ ë¦„

  ```python
      def sortList(self, head: ListNode) -> ListNode:
          # ì—°ê²° ë¦¬ìŠ¤íŠ¸ -> íŒŒì´ì¬ ë¦¬ìŠ¤íŠ¸
          p = head
          lst: List = []
          while p:
              lst.append(p.val)
              p = p.next

          # ì •ë ¬ ( list ì •ë ¬ì€ ë°˜í™˜ì´ ì—†ê³  ì œìë¦¬ì—ì„œ ì†ŒíŒ…ë¨)
          lst.sort()

          # íŒŒì´ì¬ ë¦¬ìŠ¤íŠ¸ -> ì—°ê²° ë¦¬ìŠ¤íŠ¸
          # ë”°ë¡œ ë…¸ë“œë¥¼ ë§Œë“ ê±´ ì•„ë‹ˆê³  ê¸°ì¡´ inputì— ê°’ë§Œ ì¹˜í™˜
          p = head
          for i in range(len(lst)):
              p.val = lst[i]
              p = p.next
          return 

  ```

## 56. êµ¬ê°„ ë³‘í•©

- ë¬¸ì œ 
  - ê²¹ì¹˜ëŠ” êµ¬ê°„ì„ ë³‘í•©í•˜ë¼
  - Input: intervals = `[ [1,3],[2,6],[8,10],[15,18] ]`
  - Output: `[ [1,6],[8,10],[15,18] ]`
  - > [1,3] [2,6] ì´ êµ¬ê°„ì´ ê³‚ì¹¨. ê·¸ë˜ì„œ [1,6]ë§Œë“¬

- í’€ì´ 1. ì •ë ¬í•˜ì—¬ ë³‘í•©
  - > ì •ë ¬ì— ë“œëŠ” ì‹œê°„ ë³µì¡ë„ O( n log n) ì •ë„ê°€ ë“¬. ì´ í’€ì´ì˜ ì‹œê°„ ë³µì¡ë„ëŠ”
  - > íŒ€ì†ŒíŠ¸ : ë³‘í•© + ì‚½ì…

```python

    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        merged = []
        # elementì¸ listì˜ ì²«ë²ˆì§¸ ê°’ìœ¼ë¡œ ì •ë ¬
        # ë¡œì§ì€ ë‹¨ìˆœí•œë°,, ì•ì…˜ mergedì— ë“¤ì–´ê°„ elementì˜ ëê°’ê³¼ í˜„ì¬ i elementì˜ ì‹œì‘ê°’ ë¹„êµ
        # ì‹œì‘ê°’ì´ ëê°’ë³´ë‹¤ ì•ì´ë©´ êµ¬ê°„ì´ ê³‚ì¹œë‹¤ëŠ” ê²ƒì´ë¯€ë¡œ.. mergedì˜ ëê°’ì„ ì—…ë°ì´íŠ¸
        # ê³‚ì¹˜ì¹˜ ì•Šìœ¼ë©´ mergedì— í•´ë‹¹ ìš”ì†Œ ì¶”ê°€
        for i in sorted(intervals, key=lambda x: x[0]):
            if merged and i[0] <= merged[-1][1]:
                merged[-1][1] = max(merged[-1][1], i[1])
            else:
                merged += i, # ?? íŠ¹ì´í•œ ë¬¸ë²• ì´ê±° ì¤‘ìš” í¬ì¸íŠ¸
        return merged

```
- `merged += i,`
  - ë§ˆì§€ë§‰ ,ëŠ” ì¤‘ì²©ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ ì£¼ëŠ” ì—­í• . 499p
  - ì¦‰, ë‹¤ìŒê³¼ ê°™ìŒ
  - > ì½¤ë§ˆ ì—°ì‚°ì ëª°ëë‚˜?


  ```python
  a = [1]
  b = [2,3]
  c = a + b # cëŠ” [1,2,3] ì´ë¨

  a = [1]
  b = [2,3] , 
  c = a + b # cëŠ” [1,[2,3]] ì´ë¨

  ```

## 147. ì‚½ì… ì •ë ¬ ë¦¬ìŠ¤íŠ¸

- ë¬¸ì œ  
  - ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚½ì… ì •ë ¬ë¡œ ì •ë ¬í•˜ë¼
  - > ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë‹¤ë£¨ëŠ”ê²Œ ì«Œ ì§œì¦ë‚˜ëŠ” ë¬¸ì œ ë“¤ì´ë„¤..

- í’€ì´1. ì‚½ì…ì •ë ¬
  - ì‚½ì…ì •ë ¬ ì´ë€?
  - > ë‹¨ìˆœí•œë°.. ì‹¤ìƒ ì•„ë˜ ì½”ë“œëŠ” ìª¼ê¸ˆ... ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¼ ì´í•´ê°€ ì–´ë µë„¤
  - ì´ê±° 2ì´ˆì¯¤ ê±¸ë¦¼

  ```python
  class ListNode:
      def __init__(self, x):
          self.val = x
          self.next = None


  class Solution:
      def insertionSortList(self, head: ListNode) -> ListNode:
          cur = parent = ListNode(None) # ë¹ˆ ë…¸ë“œ í•˜ë‚˜ ë‘  ( ì•„ë˜ cur.next ë•Œë¬¸.. curê°€ Noneì´ë©´ cur.next ì—ëŸ¬ì¼í…Œë‹ˆ..)
          while head:
              while cur.next and cur.next.val < head.val:
                  cur = cur.next # í˜„ì¬ headì˜ ê°’ì´ curì˜ ê°’ë³´ë‹¤ í¬ë©´ curì˜ ë…¸ë“œë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ìš©í•´ì„œ ë¹„êµ

              cur.next, head.next, head = head, cur.next, head.next # ì´ê±°ëŠ” headë¥¼ cur ë…¸ë“œë“¤ ì‚¬ì´ì— ë„£ëŠ”ê²ƒ

              cur = parent # ë‹¤ì‹œ curëŠ” ë§¨ì•ìœ¼ë¡œ ë˜ëŒë¦¼. 
          return cur.next

  ```

- í’€ì´2. ì‚½ì… ì •ë ¬ì˜ ë¹„êµ ì¡°ê±´ ê°œì„ 
  - ì‚¬ì‹¤ ìœ„ í’€ì´ëŠ” ì œëŒ€ë¡œ ëœ ì‚½ì… ì •ë ¬ì´ ì•„ë‹˜
  - ì‚½ì… ì •ë ¬ì—ì„œ ì •ë‹µì…‹(ìœ„ì˜ cur) ë‘ ë‚¨ì€ ì…‹ì„ ë¹„êµí• ë•ŒëŠ”
  - ìœ„ ì²˜ëŸ¼ ì •ë‹µì…‹ì˜ ì•ë¶€ë¶„ë¶€í„° ë¹„êµí•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ ë’¤ì—ì„œ ë¶€í„° ë¹„êµí•¨
  - > ì–´ì§œí”¼ ì´ì¤‘ì—°ê²°ë¦¬ìŠ¤íŠ¸ê°€ ì•„ë‹ˆë¼ì„œ ë’¤ì—ì„œ ëŒì•„ì˜¤ëŠ”ê²ƒì€ ëª»í•¨
  - ì—¬ê¸°ì„œëŠ” ì•½ê°„ì˜ ìµœì í™”ë¥¼ ì§„í–‰í•´ì„œ ì„±ëŠ¥ì„ ê°œì„ í•¨
    - ì´ëŸ°ì‹ì˜ ìµœì í™”ëŠ” ì‹¤ë¬´ì—ì„œë„ ì“°ì´ë‹ˆ ì˜ ìˆ™ì§€í•´ì•¼í•œë‹¤í•¨. (ë¬¼ë¡  ì½”í…Œì—ì„œë„.. )

  ```python

      def insertionSortList(self, head: ListNode) -> ListNode:
          # ì´ˆê¸°ê°’ ë³€ê²½
          cur = parent = ListNode(0)
          while head:
              while cur.next and cur.next.val < head.val:
                  cur = cur.next

              cur.next, head.next, head = head, cur.next, head.next

              # í•„ìš”í•œ ê²½ìš°ì—ë§Œ cur í¬ì¸í„°ê°€ ë˜ëŒì•„ê°€ë„ë¡ ì²˜ë¦¬ ( ì¦‰ ë§¤ ë‹¨ê³„ë§ˆë‹¤ curë¥¼ ì•ìœ¼ë¡œ ë³´ë‚´ì§€ ì•ŠìŒ)
              # headê°€ cur ì‚¬ì´ì— ë“¤ì–´ê°€ëŠ” ê²½ìš°ë§Œ curë¥¼ ì²˜ìŒìœ¼ë¡œ ë³´ë‚´ì„œ ì°¨ë¡€ë¡œ ë¹„êµí•˜ê²Œ í•œë‹¤.
              if head and cur.val > head.val: # cur.valê°€ Noneì´ë©´ ë¹„êµ êµ¬ë¬¸ì—ì„œ ì—ëŸ¬ ë‚˜ë‚˜ë´„. ê·¸ë˜ì„œ ì´ˆê¸°ê°’ 0ì¤Œ
                                              # not supported between instances of 'NoneType' and 'int'
                  cur = parent
          return parent.next

  ```

## 179. ê°€ì¥ í° ìˆ˜

- ë¬¸ì œ
  - í•­ëª©ë“¤ì„ ì¡°í•©í•˜ì—¬ ë§Œë“¤ ìˆ˜ ìˆëŠ” ê°€ì¥ í° ìˆ˜ë¥¼ ì¶œë ¥í•˜ë¼.
  - input : `[10,2]`
  - output : "210"
  - > ëŒ€ì¶© ì •ë ¬ì„ í•˜ë©´ë˜ëŠ” ë¬¸ì œ ì¸ë“¯. 10ê³¼ 2ì—ì„œëŠ” 2ì™€1ì„ ë¹„êµí•˜ëŠ” ì‹ìœ¼ë¡œ ì •ë ¬.
  - > íŠ¸ë¦­ì´ ì¬ë°Œë„¤.. a, bë¥¼ ë¹„êµí• ë•Œ ìë¦¿ìˆ˜ë¡œ ë¹„êµë¥¼ í•˜ì§€ ì•Šê³ , a + b , b + aì¤‘ ë­ê°€ í°ì§€ë¡œ íŒë‹¨

- í’€ì´1. ì‚½ì… ì •ë ¬
  - ì›ë˜ ì‚½ì… ì •ë ¬ì€ ë°°ì—´ í’€ì´ë¥¼ ê¸°ë³¸ìœ¼ë¡œ í•¨
  - ë°°ì—´ë¡œ í’€ë©´ êµ¬í˜„ì´ ê¹”ë”.
  - > ì—°ê²° ë¦¬ìŠ¤íŠ¸ ë•Œ ì²˜ëŸ¼ ìµœì í™” í•„ìš” ì—†ìŒ
  - ë°°ì—´ë¡œ êµ¬í˜„í•˜ë©´ ì œìë¦¬ ì •ë ¬ì´ ê°€ëŠ¥ ( inplace sort )
  - ì•„ë˜ ì½”ë“œê°€ ê¸°ë³¸ ì‚½ì…ì •ë ¬ ì½”ë“œë‹ˆ ì™¸ì›Œë‘ë©´ ì¢‹ìŒ
    - > ì—°ê²° ë¦¬ìŠ¤íŠ¸ ì²˜ëŸ¼ ì¤‘ê°„ì— ê¼¿ëŠ” í˜•íƒœê°€ ì•„ë‹˜
    - > ë°°ì—´ì„ ë°€ì–´ì•¼ í•˜ë‹ˆê¹Œ. ì—­ìœ¼ë¡œ ë¹„êµí•´ì„œ swapí•´ì„œ ìë¦¬ ì°¾ëŠ” í˜•íƒœ -> ì´ê²Œ ê¸°ë³¸ í˜•íƒœ.

  ```python
    from typing import List


    class Solution:
        # ë¬¸ì œì— ì í•©í•œ ë¹„êµ í•¨ìˆ˜
        @staticmethod
        def to_swap(n1: int, n2: int) -> bool:
            return str(n1) + str(n2) < str(n2) + str(n1)

        # ì‚½ì… ì •ë ¬ êµ¬í˜„ ( ì•ì„  ë¬¸ì œì™€ëŠ” ë‹¬ë¦¬ ë°°ì—´ì´ë¼ ì¸ë±ìŠ¤ ì‚¬ìš©ì´ ê°€ëŠ¥, ê·¸ë˜ì„œ êµ¬í˜„ì´ ì«Œ ë‹¤ë¦„..ë‹¹ì—°í•˜ê²Œë„..)
        def largestNumber(self, nums: List[int]) -> str:
            i = 1
            while i < len(nums):
                j = i
                while j > 0 and self.to_swap(nums[j - 1], nums[j]): # ë¹„êµë§Œ ë¹¼ë©´ ì‚½ì…ì •ë ¬ì˜ ìŠˆë„ ì½”ë“œë‘ ê°™ìŒ
                    nums[j], nums[j - 1] = nums[j - 1], nums[j] 
                    j -= 1
                i += 1

            return str(int(''.join(map(str, nums)))) # strì„ intë¡œ ë‹¤ì‹œ ë³€í™˜í•˜ëŠ” ì´ìœ ëŠ”  ["0","0"] ì¸ê²½ìš°ë•Œë¬¸. 
                                                      # ì´ê²½ìš°ëŠ” 00ì´ ë‚˜ì˜¤ë©´ ì•ˆë¨. 0ì´ ë‚˜ì™€ì•¼ í•¨
  ```

## 242. ìœ íš¨í•œ ì• ë„ˆ ê·¸ë¨

- ë¬¸ì œ
  - tê°€ sì˜ ì• ë„ˆê·¸ë¨ì¸ì§€ íŒë³„í•˜ë¼
  - 6ì¥ 49. ë¬¸ì œì™€ ìœ ì‚¬
  - s : "anagram", t : "nagaram"

- í’€ì´1. ì •ë ¬ì„ ì´ìš©í•œ ë¹„êµ

  ```python
      def isAnagram(self, s: str, t: str) -> bool:
          return sorted(s) == sorted(t)

  ```

## 75. ìƒ‰ ì •ë ¬

- ë¬¸ì œ
  - ë¹¨ê°„ìƒ‰ì„ 0, í°ìƒ‰ì„ 1, íŒŒë€ìƒ‰ì„ 2ë¼ í• ë–„ ìˆœì„œëŒ€ë¡œ ì¸ì ‘í•˜ëŠ” ì œìë¦¬ (in-place) ì •ë ¬ì„ ìˆ˜í–‰í•˜ë¼
    - > ê·¸ëƒ¥ íŒ€ì†ŒíŠ¸ ëŒë ¤ë„ ë˜ì§€ ì•Šë‚˜? ë¨.
    - > ì—¬íŠ¼ ì •ì‹ì ìœ¼ë¡œëŠ” í€µì •ë ¬. ì¦‰ íŒŒí‹°ì…”ë‹ì— ëŒ€í•œ ì•Œê³ ë¦¬ì¦˜ ì´í•´ê°€ ìˆì–´ì•¼ ì•„ë˜ë„ ì˜ ì´í•´í• ìˆ˜ ìˆìŒ
  - ì…ë ¥
    - [2,0,2,1,1,0]
  - ì¶œë ¥
    - [0,0,1,1,2,2]

- í’€ì´ 1. ë„¤ëœë€ë“œ êµ­ê¸° ë¬¸ì œë¥¼ ì‘ìš©í•œ í’€ì´
  - ë„¤ëœë€ë“œ êµ­ê¸° ë¬¸ì œëŠ” ë§¤ìš° ìœ ëª…í•œ ì»´í“¨í„° ê³¼í•™ ë¬¸ì œë¼ê³  í•¨
    - í€µ ì •ë ¬ì˜ ê°œì„  ì•„ì´ë””ì–´ì™€ ì—°ê´€ ìˆëŠ” ë¬¸ì œ. -> ì—¬ê¸°ì„œëŠ” ì´ê±¸ ì„¤ëª…í•˜ë ¤ëŠ” ê²ƒì€ ì•„ë‹˜. ê·¸ëƒ¥ ë¬¸ì œ ìì²´ì— ì§‘ì¤‘
  > ë¬¸ì œ í’€ì´ ìì²´ê°€ 0,1,2 ì„¸ê°€ì§€ ê°’ë§Œ ì¡´ì¬í• ë•Œë¡œ êµ­í•œë˜ëŠ”ê±° ê°™ì€ ëŠë‚ŒìˆìŒ. 
  > íˆ¬ í¬ì¸í„° í’€ì´ì™€ ìœ ì‚¬. ì¦‰ white ëŠ” ì˜¤ë¥¸ìª½ìœ¼ë¡œ.. blueëŠ” ì™¼ìª½ìœ¼ë¡œ ì´ë™í•˜ë©´ì„œ ì²˜ë¦¬ë¨
  - ê°œë…ì´ ì–´ë ¤ìš´ë°.. 
    - ì¼ë‹¨ ë³´ë©´
    - red index : 1ë³´ë‹¤ ì‘ì€ ì¦‰ 0 ê°’ì´ ë“¤ì–´ê°ˆ ìœ„ì¹˜ indicate 
    - white index : 1ê°’ ì¦‰ ì¤‘ê°„ì¸ë° 1ì˜ í˜„ì¬ ë§ˆì§€ë§‰ ìœ„ì¹˜ ê°€ë¦¬í‚´
    - blue index : ì˜¤ë¥¸ìª½ ê¸°ì¤€ 2ë¥¼ ì±„ì›Œì„œ 2ì˜ ë§ˆì§€ë§‰ ì™¼ìª½ì„ ê°€ë¦¬í‚´.

  ```python
      # three-way-partition
      def sortColors(self, nums: List[int]) -> None:
          red, white, blue = 0, 0, len(nums) # indexì´ë‹¤. red/white/blue ìˆœìœ¼ë¡œ ì™€ì•¼í•¨.

          while white < blue:
              if nums[white] < 1: # 1ì€ white ì¦‰ ì¤‘ê°„ì— ì™€ì•¼í•˜ëŠ” ê°’
                  nums[red], nums[white] = nums[white], nums[red]
                  white += 1
                  red += 1
              elif nums[white] > 1:
                  blue -= 1 # indexê°€ ì²˜ìŒì—ëŠ” ë°°ì—´ì˜ ë§ˆì§€ë§‰ì„ ë„˜ì–´ ìˆìŒ. ê·¸ë˜ì„œ -=1 ë¡œ ì‹œì‘ ë° ì§„í–‰
                  nums[white], nums[blue] = nums[blue], nums[white]
              else:
                  white += 1

  # nums.sort(reverse=False) ì´ê±° í•œì¤„ë¡œ í’€ë¦¬ê¸°ëŠ”í•¨.;;
  ```

## 973. ì›ì ì— kë²ˆì§¸ë¡œ ê°€ê¹Œìš´ ì 

- ë¬¸ì œ
  - í‰ë©´ìƒì— points ëª©ë¡ì´ ìˆì„ ë•Œ, ì›ì  (0,0)ì—ì„œ kë²ˆ ê°€ê¹Œìš´ ì  ëª©ë¡ì„ ìˆœì„œëŒ€ë¡œ ì¶œë ¥í•˜ë¼.
  - í‰ë©´ìƒ ë‘ ì ì˜ ê±°ë¦¬ëŠ” ìœ í´ë¦¬ë“œ ê±°ë¦¬ë¡œ í•œë‹¤. 
  - ì…ë ¥
    - points = `[ [1,3],[-2,2] ]` k =1
  - ì¶œë ¥
    - `[ [-2,2] ]`

- í’€ì´ 1. ìœ í´ë¦¬ë“œ ê±°ë¦¬ì˜ ìš°ì„ ìˆœìœ„ í ìˆœì„œ
  - > ìš°ì„ ìˆœìœ„ í. í™ìœ¼ë¡œ ë§Œë“¤ì—ˆìŒ. ( íŒŒì´ì¬ í™ì€ min í™)
  - k ë²ˆ ì¶”ì¶œì´ë¼ê³  í•´ì„œ ìš°ì„ ìˆœìœ„ íë¥¼ ë– ì˜¬ë¦¼. 

  ```python
  import heapq
  from typing import List


  class Solution:
      def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:
          heap = []
          for (x, y) in points:
              dist = x ** 2 + y ** 2 # ì›ë˜ ë£¨íŠ¸ ì”Œì›Œì•¼ í•˜ëŠ”ë°.. ë­ êµ³ì´ ê·¸ëŸ´í•„ìš”ê°€ ì—†ìŒ
              heapq.heappush(heap, (dist, x, y)) # íŠœí”Œì´ elementì¸ê²½ìš° ë§¨ ì•ìš”ì†Œ ê¸°ì¤€ ì •ë ¬

          result = []
          for _ in range(K):
              (dist, x, y) = heapq.heappop(heap)
              result.append((x, y))
          return result
  ```
# 18장. 이진 검색

## 개요

- 별 내용없음
- BST는 자료구조이고 이진 탐색(검색)은 정렬된 배열에서 값을 찾아내는 알고리즘
- > 정렬된 배열이라는게 핵심

## 704. 이진 검색

- 문제
  - 정렬된 nums를 입력받아 이진 검색으로 target에 해당하는 인덱스를 찾아라
  - 입력
    - nums = `[-1,0,3,5,9,12]` target = 9
  - 출력
    - 4

- 풀이 1. 재귀 풀이

    ```python

    class Solution:
        def search(self, nums: List[int], target: int) -> int:
            def binary_search(left, right):
                if left <= right:
                    mid = (left + right) // 2 

                    # 중간값 구해서 target이랑 비교해서 좌측 또는 우측으로 다시 search
                    if nums[mid] < target:
                        return binary_search(mid + 1, right)
                    elif nums[mid] > target:
                        return binary_search(left, mid - 1)
                    else:
                        return mid # 답
                else:
                    return -1

            return binary_search(0, len(nums) - 1)

    ```

  - 참고로 파이썬의 default 재귀 호출 횟수 제한은 1000임. 👍
    - 물론 값 변경 가능한데. 코테에서는 불가
    - 앞선 예를 기준으로 배열의 요소 갯수 2^1000 개까지 처리 가능 ( 이진 탐색은 logN이라서.)

- 풀이 2. 반복 풀이
  - > 대부분의 재귀는 반복 풀이 가능

  ```python
      def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2

            if nums[mid] < target:
                left = mid + 1 # target이 mid의 오른쪽 에 있다는 말이라서. left를 옮김. 
            elif nums[mid] > target:
                right = mid - 1
            else:
                return mid
        return -1
  ```

- 풀이 3. 이진 검색 모듈
  - 앞서 이진 검색을 직접 구현했는데. 그럴필요가 없음. python은 이진 검색 모듈 제공함 👍
  - bisect 알아둘 필요있음 -> 삽입 위치도 알려준다함 👍

    ```python
    import bisect
    from typing import List

    class Solution:
        def search(self, nums: List[int], target: int) -> int:
            index = bisect.bisect_left(nums, target) 

            if index < len(nums) and nums[index] == target:
                return index
            else:
                return -1

    ```

- 풀이 4. 이진 검색을 사용하지 않는 index 풀이
  - 앞선 풀이들은 이진검색을 사용한거.
  - 여기서는 파이썬의 index 메소드를 이용해 풀이
    - index() -> 해당 값의 인덱스를 찾아주는 메소드
    - index는 O(n)의 수행시간을 같는 함수 이다. 👍 👍

    ```python

        def search(self, nums: List[int], target: int) -> int:
            try:
                return nums.index(target)
            except ValueError: # 값이 없으면 에러 나서.. 예외 처리 해줌
                return -1

    ```

- 이진 검색 알고리즘 버그 523p
  - > 그냥 읽어 볼만함
  - 다른언어들은 `mid = (left + right) // 2` 에서 오버플로 날수 있다는거
  - 파이썬은 임의 정밀도 정수형이라 상관없음.

## 33. 회전 정렬된 배열 검색

- 문제
  - 특정 피벗을 기준으로 회전하여 정렬된 배열에서 target 값의 인덱스를 출력하라
  - > 문제 이해도 어렵네 
  - > 이거 잘 봐둬야 할듯 👍 어려움.
  - 입력
    - num = `[4,5,6,7,0,1,2,]`, taget =1
  - 출력 
    - 5
    - > 1의 위치가 index 5임
    - > 그리고 num이 정렬되어 있기는함. 근데 0 부터 정렬은 아님. 여기서는 피벗 4
    - > 즉 앞으로 떙겼다고 보면되는듯.  


- 풀이1. 피벗을 기준으로 한 이진 검색
  - > 최소값을 이진 검색으로 찾는 알고리즘이 신기.. 잘 이해 안되었음

```python
    def search(self, nums: List[int], target: int) -> int:
        # 예외 처리
        if not nums:
            return -1

        # 최소값 찾아 피벗 설정 ( 대충 감은오는데..)
        # 정렬된 상태라고 해서, 일단 이진 검색 으로 최소값(피벗 위치) 찾음 ( 최소값의 위치가 원래 피벗의 위치 일테니..)
        left, right = 0, len(nums) - 1 # 이거 착각 했음 ;; 👍   left 는 0 , right는 len(nums) -1 임. 멀티플 어사인임.
        while left < right:
            mid = left + (right - left) // 2 # 이진검색 버그 수정 버전

            if nums[mid] > nums[right]: # 중앙값이 right보다 크다? 그럼 mid+1이 최소일 가능성이 있음
                left = mid + 1
            else:
                right = mid # 이경우는 정상적인 정렬이므로.. 왼쪽을 다시 탐색
        # pivot = nums.index(min(nums))  이렇게 해서 한큐에 최소값 위치 찾을수도 있기는함 ( 근데 수행시간.. 이슈는 있을듯)


        pivot = left # 피봇은 값들을 오른쪽으로 얼마나 밀었냐? 를 말함. 즉 left 포인터의 위치.. 가 되겠지.. 이 문제에서는

        # 피벗 기준 이진 검색
        # 개념이 중요한데. 배열에서 이진 검색은 동일하게하는데, 대신 해당 인덱스의 값을 비교하는게 아니고, 피봇만큼 옮겨진 위치의 값을 가져와서 비교
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            mid_pivot = (mid + pivot) % len(nums)

            if nums[mid_pivot] < target:
                left = mid + 1
            elif nums[mid_pivot] > target:
                right = mid - 1
            else:
                return mid_pivot
        return -1

```

## 349. 두 배열의 교집합

- 문제
  - 두 배열의 교집합을 구하라
  - 입력
    - num1 =`[1,2,2,1]`, num2 =`[2,2]`
  - 출력
    - `[2]`
  - > 파이썬 set으로는 안될듯. 중복 값있어서..

- 풀이1. 브루트 포스로 계산

- 풀이2. 이진 검색으로 일치 여부 판별

- 풀이3. 투 포인터로 일치 여부 판별

## 167. 두 수의 합2

## 240. 2D 행렬 검색2

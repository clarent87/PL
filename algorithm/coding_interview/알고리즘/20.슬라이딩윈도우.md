# 20장. 슬라이딩 윈도우

- > 내가 알고있는 슬라이딩 윈도우 그거임
- 알고리즘 책에 나와있는 내용이 아님
- 네트워크에서 사용되던 알고리즘을 문제 풀이에 응용한것

- 투포인터(7장 참조) 와 함께 알고리즘 문제 풀이에 매우 유용하게 사용되는 기법이다.
- 투포인터 vs 슬라이딩 윈도우 569p
  - 투포인터
    - 정렬된 배열을 대상으로 함
    - 배열 앞,끝에 포인터가 위치
      - 이후 범위를 좁혀가면서 문제를 해결
      - > 물론 이방식 외에 여러가지 방식이 있을수 있음. 투 포인터 전략이 명확히 정의된 전략이 아님.
      - > 아마 런너 기법도 투 포인터 전략 부류 일듯.
    - > 자세한 내용은 189에 있음
  - 슬라이딩 윈도우
    - 고정 사이즈의 윈도우를 활용
    - 정렬 여부 관계없이 사용
    - 이동은 좌 또는 우 단방향

여기서는 투포인터/슬라이딩 윈도우를 자유롭게 혼용해서 풀이함. ( 두개를 명확히 구분하는것은 의미가 없다)

## 239. 최대 슬라이딩 윈도우

- 문제
  - 배열 nums가 주어졌을 떄 k 크기의 슬라이딩 윈도우를 오론쪽 끝까지 이동하면서 최대 슬라이딩 윈도우를 구하라
  - 입력
    - num = `[1,3,-1,-3,5,3,6,7]` k = 3
  - 출력
    - [3,3,5,5,6,7]
    - 슬라이딩 윈도우를 이동해 가며, 슬라이딩 윈도우 안의 값중 최대 값을 출력한것

- 풀이1. 브루트 포스로 계산

    ```python
        def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
            if not nums:
                return nums

            r = []
            for i in range(len(nums) - k + 1):
                r.append(max(nums[i:i + k])) # 그냥 슬라이싱 하고 안의 값중 최대값 뽑아서 append

            return r
    ```

- 시간복잡도 O (k * n)
  - 매번 윈도우 최댓값 계산하니까. 이거를 명시해줌. k로.. ( 이게 영향을 주긴 하니까.)

- 풀이2. 큐를 이용한 최적화
  - 위 풀이를 조금 개선한것
  - 어짜피 슬라이딩 윈도우를 한칸씩 이동하는 부분은 개선을 할수가 없음.
  - 최대값 찾는거는 정렬되지 않았을땐 어짜피 한번은 봐야 해서 O(n) 이상 줄일수 없음
    - 그래도 여기서는 계산된 최대값을 저장하고 새로들어온 값에 대해서 만 비교해서 교체하는 형태로 연산을 좀 줄임

    ```python
        def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
            results = []
            window = collections.deque() # 풀이1 처럼 슬라이싱을 하지는 않게 window 수정되었네
            current_max = float('-inf')

            for i, v in enumerate(nums):
                window.append(v)
                if i < k - 1:
                    continue # 일단 window에 값들을 k만큼 채움

                # 새로 추가된 값이 기존 최대값보다 큰 경우 교체
                if current_max == float('-inf'): #초기에는 값넣어야함
                    current_max = max(window)
                elif v > current_max:
                    current_max = v

                results.append(current_max)

                # 최대값이 윈도우에서 빠지면 초기화 (윈도우에 남은 값중 뭐가 최대인지 모르게되는것.)
                if current_max == window.popleft():
                    current_max = float('-inf')

            return results
    ```

  - 이방식으로 성능이 5배 빨라짐

## 76. 부분 문자열이 포함된 최소 윈도우

- 문제
  - 문자열 S와 T를 입력받아 O(n)에 T의 모든 문자가 포함된 S의 최소 윈도우를 찾아라
  - 입력
    - S = "ADOBECODEBANC" , T ="ABC"
  - 출력
    - "BANC"

- 풀이1. 모든 윈도우 크기를 브루트 포스로 탐색
  - T의 크기로 윈도우 세팅한뒤, 전체 돌리고
  - T+1 크기 윈도우로 세팅한뒤, 전체 돌리고.. 이런식
  - > 딱 봐도 O(n^2) 이라 짜피 안풀임. 문제 제한 조건에도 맞지 않고.
  - > 아 추가적으로. 문자 단위의 포함 여부 판별은 원래 어렵다
    - > 반드시 일대일로 문자가 대응되어야 한다는 점.
    - > 전체를 한번에 비교하기도 어렵고, 정렬해서 풀이하기도 어려움
    - > 즉. 거의 O(n) 걸린다고 봐야하나봄
    - > 음. hash 이용하면 쫌 나을거 같긴함

    ```python
        def minWindow(self, s: str, t: str) -> str:
            # 아래 함수가 중요
            def contains(s_substr_lst: List, t_lst: List):
                for t_elem in t_lst:
                    if t_elem in s_substr_lst:
                        s_substr_lst.remove(t_elem) # list의 remove 함수 이용했네. O(n) 일듯.
                                                    # 일부러 remove를 한듯. 나름 최적화
                    else:
                        return False # t에 요소가 window에 들어있지 않는경우.
                return True # 이경우는 위 for문이 다돌았을때. 즉 t의 문자가 window에 모두 들어있을때임

            if not s or not t:
                return ''

            window_size = len(t)

            for size in range(window_size, len(s) + 1): # 윈도우 사이즈 증가
                for left in range(len(s) - size + 1): # 윈도우 사이즈 만큼은 빼고 돌아야함
                    s_substr = s[left:left + size] # 윈도우 만큼 슬라이싱
                    if contains(list(s_substr), list(t)): # string을 list로 만들어서 넘김
                        return s_substr
            return ''
    ```

- 풀이2. 투 포인터, 슬라이딩 윈도우로 최적화
  - 이런 유형의 문제는 투 포인터를 사용하면 O(n^2)에서 O(n)으로 줄일수 있음
  - > 아.. 투포인터 유형은 잘 해결책이 떠오르는 편은 아니네,, 풀이는 비슷한거 같은데..
  - 개념
    - 슬라이딩 윈도우를 오른쪽 포인터를 이동시키며 증가시킴
      - 이때 t의 모든 문자가 포함되는지 check ( hash 이용)
    - 모든 문자가 포함된 순간, 윈도우의 왼쪽 포인터을 줄여서 모든 문자가 포함되는지 확인
      - 모든 문자가 포함되는 위치까지 줄임
    - 이 윈도우를 이동. 
    - 만약 이동한 윈도우에서 모든 문자를 포함하는 순간이 또나왔다면
      - 윈도우 왼쪽을 줄여봄.
    - 이런식으로 끝까지 진행
    - > 수행시간 O(n) 맞아?

    ```python
        def minWindow(self, s: str, t: str) -> str:
            need = collections.Counter(t)
            missing = len(t)
            left = start = end = 0

            # 오른쪽 포인터 이동
            for right, char in enumerate(s, 1):
                missing -= need[char] > 0
                need[char] -= 1

                # 필요 문자가 0이면 왼쪽 포인터 이동 판단
                if missing == 0:
                    while left < right and need[s[left]] < 0:
                        need[s[left]] += 1
                        left += 1

                    if not end or right - left <= end - start:
                        start, end = left, right
                    need[s[left]] += 1
                    missing += 1
                    left += 1
            return s[start:end]
    ```

- 풀이3. Counter로 좀 더 편리한 풀이

```python

```

## 424. 가장 긴 반복 문자 대체

- 문제

# 21장. 그리디 알고리즘

## 개요

- 정의
  - 그리디 알고리즘은 글로벌 최적을 찾기 위해 각 단계에서 로컬 최적의 선택을 하는 휴리스틱 문제 해결 알고리즘다.
- 특징
  - 대부분의 경우 뛰어난 결과를 도출하지는 못함
  - 드물게 최적해를 보장하는 경우도 있음
  - 그리디 알고리즘은 최적화 문제를 대상으로 함
    - 최적해를 찾을 수 있으면 그것을 목표로하고
    - 찾기 어려운 경우에는 주어진 시간 내에 그런대로 괜찮은 해를 찾는것을 목표로함.
  - 대부분의 문제들은 로컬 최적해( locally optimum solution) 을 찾는 탐욕스러운 방법으로는 문제 해결이 안됨
  - 하지만 합리적인 시간 내에 최적에 가까운 답을 찾을 수 있다는 점에서 매우 유용함.

- 그리디 알고리즘이 잘 작동하는 문제 특징
  - 탐욕 선택 속성( greedy choice property)를 갖고 있는 최적 부분 구조(optimal substructure)인 문제들
  - 아래 두 조건을 만족하면 최적해를 찾는것이 가능하다.
    - 뭐. 두 조건 만족못해도, 그리디는 정답을 근사하게 찾는 용도로 활용가능. 대부분의 경우 계산속도가 빨라서 실용적.
  - 탐욕 선택 속성
    - 앞선 선택이 이휴 선택에 영향을 주지 않는 것들
  - 최적 부분 구조
    - 문제의 최적 해결 방법이, 부분 문제에 대한 최적 해결 방법으로 구성된 경우.
    - > 23장. 다이나믹 프로그래밍에서 다시 한번 설명함.

- 그리디 알고리즘이 잘 작동하는 예
  - 13장의 다익스트라 알고리즘
    - 대표적인 그리디 알고리즘예, 최적해를 찾을수 있음
  - 압축 알고리즘인 허프만 코딩 (huffman coding)알고리즘
    - 허프만 트리를 빌드 할때 그리디 알고리즘 사용 -> 최적해 보장됨
  - 머신러닝의 의사결정 트리 알고리즘으로 유명한 ID3 알고리즘
    - 항상 최선의 답을 찾아 트리를 빌드해감. 물론 이 경우는 최적에 가까운 답을 찾을수 있지만, 항상 최적해를 찾는것은 아님

- 그리디 vs 다이나믹 프로그래밍
  - 최적 부분 구조 문제를 푼다는 점에서 두가지가 비교됨
  - 서로 풀수 있는 문제의 성격이 다르며, 알고리즘의 접근 방식도 다름
  - 다이나믹 프로그래밍
    - 하위 문제에 대한 최적의 솔루션을 찾은다음, 이 결과들을 결합한 정보에 입각해
    - 전역 최적 솔루션(globally optimum solution)에 대한 선택을 함
  - 그리디
    - 각 단계마다 로컬 최적해를 찾는 문제로 접근해 문제를 더 작게 줄여나가는 형태로 진행

- 그리디 알고리즘을 중심으로 풀 수 있는 문제, 다이나믹 프로그래밍으로 풀어햐 하는 문제, 그리디로는 풀수 없는문제는 다음과 같다.

### 배낭문제

- 문제
  - 15kg을 채울수 있는 가방이 있고, 가격/무게가 있는 짐이 여러개 있다.
  - 이때 가방을 최대로 비싸게 채우는 방법은?
- 의미
  - knapsack problem인데, 이는 조합 최적화(combinatorial optimization) 분야에서 매우 유명한 문제
  - 두가지 형태가 있음
    - 짐을 쪼갤수 있는 경우
      - fractional knapsack problem
      - 그리디로 해결 가능
    - 짐을 쪼개지 못하는 경우
      - 23장에 문제로 나오는데, 이건 다이나믹으로 풀어야함

```python
cargo = [
    (4, 12),
    (2, 1),
    (10, 4),
    (1, 1),
    (2, 2),
]


def fractional_knapsack(cargo):
    capacity = 15
    pack = []
    # 단가 계산 역순 정렬
    for c in cargo:
        pack.append((c[0] / c[1], c[0], c[1])) # 단가, 가격, 무게
    pack.sort(reverse=True) # 기본적으로 element가 튜플이면 첫 요소가 key가되는듯.

    # 단가 순 그리디계산
    total_value: float = 0
    for p in pack:
        if capacity - p[2] >= 0:
            capacity -= p[2]
            total_value += p[1]
        else:
            fraction = capacity / p[2] # 비율 구해서
            total_value += p[1] * fraction # 가격에 비율만큼만 구해서 더함
            break

    return total_value


r = fractional_knapsack(cargo)
print(r)

```

- 중요 포인트 sort함수.
  - list의 요소가 튜플이면(아마 다른 iterable도?) 첫 요소를 키로 정렬하나봄.
  - 참고로 sort함수에 어떤 key를 선택할지 lambda로 줄수 있었음. 그리고 main 키 second 키 설정도 되고.
  - <https://gorokke.tistory.com/38>

### 동전 바꾸기 문제

- 문제
  - 160원을 돌려줘야한다.
  - 거스름돈 동전은 여러 종류가 있다. 각 동전을 최대한 활용해서 거슬러 주는 방법은?

- 케이스
  - 동전의 액면가가 이전 액면의 배수 이상인 경우
    - 즉, 10원, 50원, 100원
    - 이경우는 그리디로 해결가능
  - 동전의 액면가가 위와 같지 않은 경우
    - 즉, 160원 거슬러 줘야하는데, 10,50, **80**, 100원 있는경우
    - 이경우는 그리디로 해결이 안됨
      - 100원 선택하고 나면 50, 10을 선택 총 3가지 동전을 줘야하는데
      - 실제 답은 80원 두개.
    - 이경우는 다이나믹으로 풀어야함

### 가장큰합

그리디 알고리즘 실패 사례

- 노드를 더해가다 마지막에 가장 큰합이 되는 경로를 찾는 문제..
  - 책을 보니 7 - 3 - 99 경로가 있는데
  - 7 - 12 - 6 경로를 선택하게된.. 그리디는
  > 실패 이유는 다익스트라랑 다르긴하네.. 애당초 문제 유형이 다름
  
이 문제는 이진트리를 정렬한다든지.. 등의 추가 작업 없이는 그리디로 풀수는 없음
> 정렬한다 해도.. 어떻게 정렬?

아래 문제들은 그리디로 풀수 있는 것들

## 122. 주식을 사고팔기 가장 좋은 시점 2

- 문제
  - 여러 번의 거래로 낼 수 있는 최대 이익을 산출하라
  - 입력
    - `[7,1,5,3,6,4]`
    - > 1일때 사서, 5일떄 매도, 3일때 사서 6에 매도, 총 이득 7
  - 출력
    - 7
  - 7장. 배열에서 풀어본 주식을 사고팔기 가장 좋은 시점. 문제의 2탄
  - 그떄와는 다르게, 여러번 거래 할수 있다는 차이가 있음

- 풀이1. 그리디 알고리즘
  > 문제에서 다음번 등락여부를 알수 있으니 -> 현실에선 불가
  > 내리기 전에 팔고, 오르기 전에 사면됨
  > 아래 코드는 오를때 사서 -> 팔고 바로 이득 취함. 이렇게 해도 됨

  ```python
    def maxProfit(self, prices: List[int]) -> int:
        result = 0
        # 값이 오르는 경우 매 번 그리디 계산
        for i in range(len(prices) - 1): # 마지막 하나는 일부러 뺀듯, 해당 값은 다음 값이 없어서 처리 불가
            if prices[i + 1] > prices[i]: # 오르면 산다는 의미
                result += prices[i + 1] - prices[i] # 오를때사고 팔아서 이득 남겼다는 의미.
        return result
  ```
  
- 풀이2. 파이썬 다운 방식

  ```python
      def maxProfit(self, prices: List[int]) -> int:
          
          # 0보다 크면 무조건 합산 -> 생각해보면 매 단계 이득을 계산해서 음수인 경우는 빼면 되긴함
          return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))
  ```

## 406. 키에 따른 대기열 재구성 👍

- 문제
  - 여러 명의 사람들이 줄을 서 있다. 각각의 사람은 (h,k) 의 두 정수 쌍을 갖는데,
  - h는 그 사람의 키, k는 앞에 줄 서 있는 사람들 중 자신의 키 이상인 사람들의 수를 뜻한다.
  - 이 값이 올바르도록 줄을 재정렬하는 알고리즘을 작성하라.
  - 입력
    - `[[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]`
  - 출력
    - `[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]`
  - > 그냥 보면 정렬 알고리즘 물어보는 문제로 보이는데..

- 풀이1. 우선순위 큐 이용
  - 문제를 보면 일정한 패턴이 있음 -> 우선순위 큐로 쉽게 풀이됨
  - 우선순위 큐는 매번 그때그때 최소 또는 최대값을 추출하기 때문에 -> 그리디에 어울리는 대표 자료구조 👍 👍
  - 실제로 그리디 문제 대부분은 우선순위 큐를 이용해 푼다 👍 👍
  - > 가장큰 애들 순으로 뽑아서 k값을 index로 삼아서 넣으면됨
  - > ex : [7,0] 은 가장 큰애고 앞에 7이상인게 없음
  - >      [7,1] 은 앞에 7이상인게 하나 있음. 그럼 index 1에 넣음
  - >      [6,1] 은 7다음으로 큰데 앞에 6보다 큰게 하나 있음. 그럼 index 1에 넣음..

```python
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        
        heap = []
        # 키 역순, 인덱스 삽입
        for person in people:
            heapq.heappush(heap, (-person[0], person[1])) # 파이썬은 최소힙만 지원하니까. 음수로 최대힙 만듬

        result = []
        # 키 역순, 인덱스 추출
        while heap:
            person = heapq.heappop(heap)
            result.insert(person[1], [-person[0], person[1]])
        return result
```

## 621. 태스크 스케쥴러

- 문제
  - A에서 Z로 표현된 태스크가 있다. 각 간격마다 CPU는 한번의 태스크만 실행할 수 있고,
  - n번의 간격 내에는 동일한 태스크를 실행할 수 없다. 
  - 더 이상 태스크를 실행할 수 없는 경우 아이들(idle) 상태가 된다. 
  - 모든 태스크를 실행하기 위한 최소 간격을 출력하라.
  - 입력
    - tasks = `["A","A","A","B","B","B"]` ,n=2
  - 출력
    - 8
  - 설명
    - A -> B -> idle -> A -> B -> idle -> A -> B
    - > 문제 이해가 어렵네.. 
    - > A -> A 사이에는 n번의 간격이 필요함. 따라서 A -> B -> idle -> A 가됨.

- 풀이1. 우선순위 큐 이용
  - 우선순위 큐로 그리디 하게 풀수 있음
  - 근데 아이템 추출후 매번 아이템 갯수 업데이트가 필요
  - heapq만으로는 구현하기 번거로운 작업들.. 따라서 여기서는 Counter 모듈을 사용해서 파이썬 답게 풀이함
  - > 아래 코드는 몇가지 트릭이 있고, 직관적으로 알아내기 어려운 부분들이 있음
  - 설명
    - 우선 우선 순위 큐를 사용해 가장 개수가 많은 아이템부터 하나씩 추출해야함
    - 이때 하나 추출하고 해당 아이템의 개수를 업데이트할 구조가 필요

```python
import collections
from typing import List


class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        counter = collections.Counter(tasks)
        result = 0

        while True:
            sub_count = 0
            # 개수 순 추출
            for task, _ in counter.most_common(n + 1):
                sub_count += 1
                result += 1

                counter.subtract(task)
                # 0 이하인 아이템을 목록에서 완전히 제거
                counter += collections.Counter()

            if not counter:
                break

            result += n - sub_count + 1

        return result
```

## 134. 주유소

## 455. 쿠키 부여

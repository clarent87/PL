# 10ì¥. ë°í¬, ìš°ì„ ìˆœìœ„ í

- deque
  - ìŠ¤íƒê³¼ í íŠ¹ì§•ì„ ëª¨ë‘ ê°€ì§
  - ì•ì„  ì›í˜•íì˜ rearì—°ì‚°ì€ ì‚¬ì‹¤ dequeì˜ ì—°ì‚°
  - ì–‘ìª½ ì‚½ì… ì‚­ì œ ê°€ëŠ¥
  - êµ¬í˜„ì€ ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ í•˜ëŠ”ê²Œ ê°€ì¥ ì–´ìš¸ë¦¼
  - íŒŒì´ì¬ì€ collections.deque() ê°€ ìˆìŒ
    - > ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ êµ¬í˜„ë¨

- ìš°ì„ ìˆœìœ„ í ( 273pì—ë„ ë‚˜ì˜´ )
  - ì¶”ì¶œ ìˆœì„œê°€ ì¼ì •í•˜ì§€ ì•ŠìŒ
  - > ì¦‰ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì¶”ì¶œë ë“¯
  - ì •ë ¬ + íë¥¼ ì´ìš©í•˜ë©´ ë§Œë“¤ìˆ˜ ìˆìŒ
    - ìƒˆ ìš”ì†Œ ì‚½ì…, ì‚­ì œì‹œ ê±¸ë¦¬ëŠ” ì‹œê°„
      - O(S(n)) . S(n)ì€ ì •ë ¬ì— ê±¸ë¦¬ëŠ” ì‹œê°„
      - ë³´í†µ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì€ O(n logn) ì¦‰, O(S(n)) =  O(n logn) ê°€ ë˜ëŠ”ë°..
      - ì‚¬ì‹¤ ì‹¤ì œ êµ¬í˜„ì€ ë‹¨ìˆœ ì •ë ¬ ë³´ë‹¤ëŠ” í™ ì •ë ¬ ë“±ì˜ íš¨ìœ¨ì ì¸ ë°©ë²• í™œìš©
  - ì–´ì¨‹ë“  ì •ë ¬ëœ ìƒí™©ì—ì„œ ì•ìª½ dataê°€ì ¸ì˜¤ëŠ” ê²ƒì€ O(1)
  - ìš°ì„ ìˆœìœ„ íëŠ”
    - ë‹¤ìµìŠ¤íŠ¸ë¼ì—ì„œë„ ì“°ì´ê³ , í™ìë£Œêµ¬ì¡°ì™€ë„ ì—°ê´€ì´ ìˆìŒ
    - > ì•„ë§ˆ í™ìœ¼ë¡œ ìš°ì„ ìˆœìœ„ íë¥¼ ë§Œë“¤ì§€ ì•Šì•˜ë‚˜?
  - íŒŒì´ì¬ì—ì„œëŠ” ìš°ì„ ìˆœìœ„ í í’€ì´ì— PriorityQueueëŠ” ì•ˆì“°ê³  ê±°ì˜ í•­ìƒ heapqì”€
  - https://docs.python.org/ko/3/library/heapq.html

- íŒŒì´ì¬ PriorityQueue ì•ˆì“°ëŠ” ì´ìœ 
  - PriorityQueueëŠ” ë‚´ë¶€ì ìœ¼ë¡œ heapq ì´ìš©í•´ì„œ êµ¬í˜„
  - ì°¨ì´ì ì€ thread safeí•˜ë‹¤ëŠ”ê²ƒ
  - ê·¼ë° íŒŒì´ì¬ì€ GIL íŠ¹ì„±ìƒ ë©€í‹°ì“°ë ˆë”©ì€ ê±°ì˜ ì—†ìŒ. ë©€í‹° í”„ë¡œì„¸ì‹±ì„ ì£¼ë¡œ ì´ìš©í•˜ê¸° ë•Œë¬¸.
    - > ìŠ¤ë ˆë“œ ì„¸ì´í”„í•˜ê²Œ ë§Œë“¤ë©´ ì„±ëŠ¥ì˜ í•˜ë½ì´ ìˆìŒ. lock ë•Œë¬¸
  - ì‹¤ë¬´ì—ì„œë„ ëŒ€ë¶€ë¶„ heapqë¡œ ìš°ì„ ìˆœìœ„ íë¥¼ ë§Œë“¤ì–´ì„œ ì”€
  - ìµœì†Œí™ . ìµœëŒ€í™ ë° í™ ê°œë…
    - ìµœì†Œí™ 
      - ë¶€ëª¨ì˜ keyê°€ ìì‹ë³´ë‹¤ ì‘ì€ê²ƒ
      - `heapq.heappush(freqs_heap, (-freqs[f], f))` ì—ì„œ ë’¤ íŠœí”Œì˜ index 0ê°€ keyì´ë‹¤.

- 278p GIL
  - í•´ë‹¹ íŒŒì´ì¬ íŠ¹ì§•ì€ ì•„ì§ë„ ì£¼ìš” íŠ¹ì§•ì´ë‹¤. ê±·ì–´ë‚´ë ¤ëŠ” ì‹œë„ëŠ” ìˆì–´ì™”ì§€ë§Œ..
  - GIL = ì „ì—­ ì¸í„°í”„ë¦¬í„° ë½
  - í•˜ë‚˜ì˜ ì“°ë ˆë“œê°€ íŠ¹ì • ì‹œê°„ ë™ì•ˆ ìì› ë…ì . cpu coreê°€ í•˜ë‚˜ì¼ë• ê´œì°®ì•˜ìŒ
  - ì´ ì˜ë¯¸ëŠ”, ì“°ë ˆë“œ ë³‘ë ¬ì²˜ë¦¬ë¥¼ í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì˜ë¯¸, ë‹¨ìˆœíˆ ì‹œë¶„í• ë¡œ ì“°ë ˆë“œì— ìì›ì„ í• ë‹¹í•´ì„œ ëŒë ¤ì“´ë‹¤ëŠ” ê²ƒ

## 641. ì›í˜• ë°í¬ ë””ìì¸

- ì•ì„  ë¬¸ì œì—ì„œëŠ” ì›í˜• íë¥¼ ë§Œë“¤ì—ˆëŠ”ë°, ì—¬ê¸°ëŠ” ì›í˜• ë°í¬ì„
- ì›í˜• íì—ì„œëŠ” ì•ì—ë‹¤ dataë¥¼ ë„£ëŠ” ì—°ì‚°ì€ ì—†ì—ˆìŒ
  - ë‹¹ì—°. íëŠ” ë’¤ì—ë‹¤ë§Œ dataë¥¼ ë„£ìŒ
  - ë°°ì—´ì„ ì´ìš©í•œ íì—ì„œ ì•ì— dataë¥¼ ë„£ìœ¼ë ¤ë©´ dataë“¤ì„ ì „ë¶€ í•œì¹¸ì”© ë°€ì–´ì•¼í•¨ -> O(n)
- ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ëŠ” ì•ì— dataë„£ê¸° ì‰¬ì›€

- ê·¼ë° ì‚¬ì‹¤ ì›í˜• ë°í¬ëŠ” ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ êµ¬í˜„í•˜ë©´ ì›í˜•ì˜ ì´ì ì„ ì „í˜€ ì‚´ë¦´ìˆ˜ ì—†ìŒ
  - > ì´ê±´ ì›í˜• íë„ ë§ˆì°¬ê°€ì§€
  - > ì›í˜•ì€ ë¬´ì¡°ê±´ ë°°ì—´ì´ì—¬ì•¼ ì´ì ì´ ìƒê¹€
  - > ì—°ê²° ë¦¬ìŠ¤íŠ¸ëŠ” ì• ì´ˆì— ë¹ˆê³µê°„ì˜ ê°œë…ì´ ì—†ê¸° ë–„ë¬¸.
- ê²Œë‹¤ê°€ í ë‚˜ ë°í¬ëŠ” ì•ë’¤ ê°’ë§Œ í•œê°œì”© ì¶”ì¶œí•˜ë©´ ë˜ë¯€ë¡œ, ì—°ê²° ë¦¬ìŠ¤íŠ¸ì¼ í•„ìš”ë„ ì—†ìŒ
  - > ë§¨ ëì˜ ë‹¤ìŒ ì¸ë±ìŠ¤ ë…¸ë“œë¥¼ ì¶”ì¶œí•œë‹¤. ë­ ì´ëŸ¬ë©´ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì—¬ì•¼ í•˜ì§€ë§Œ..

```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class MyCircularDeque:
    def __init__(self, k: int):
        self.head, self.tail = ListNode(None), ListNode(None) # ì¦‰ ì´ˆê¸°ì— nodeë¥¼ ë‘ê°œë¥¼ ë§Œë“¤ì–´ì„œ ì—°ê²°í•´ë‘  ( ë”ë¯¸ ë…¸ë“œ í•„ìš”)
        self.k, self.len = k, 0
        self.head.right, self.tail.left = self.tail, self.head

    # ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì— ì‹ ê·œ ë…¸ë“œ ì‚½ì…
    # nodeA(node) - nodeB ê°€ ìˆë‹¤ë©´
    # nodeA - new - nodeB ë¡œ ë§Œë“¬
    # ë”°ë¼ì„œ tail ì‚½ì…ì‹œì—ëŠ” tail(nodeB)ë¥¼ ì£¼ë©´ì•ˆë˜ê³  tail.leftë¥¼ ë„£ì–´ ì¤˜ì•¼í•¨
    def _add(self, node: ListNode, new: ListNode):
        n = node.right # headì˜ ê¸°ì¡´ right ì„ì‹œ ì €ì¥. ì¦‰ nì€ temp
        node.right = new
        new.left, new.right = node, n
        n.left = new

    def _del(self, node: ListNode):
        n = node.right.right
        node.right = n
        n.left = node

    def insertFront(self, value: int) -> bool:
        if self.len == self.k:
            return False
        self.len += 1
        self._add(self.head, ListNode(value))
        return True

    def insertLast(self, value: int) -> bool:
        if self.len == self.k:
            return False
        self.len += 1
        self._add(self.tail.left, ListNode(value)) # ë§ˆì§€ë§‰ì— ë„£ëŠ”ê²ƒì¸ teil.leftë€ ê²ƒë§Œ insertFrontê°€ ì°¨ì´ ìˆë„¤
        return True

    def deleteFront(self) -> bool:
        if self.len == 0:
            return False
        self.len -= 1
        self._del(self.head)
        return True

    def deleteLast(self) -> bool:
        if self.len == 0:
            return False
        self.len -= 1
        self._del(self.tail.left.left)
        return True

    def getFront(self) -> int:
        return self.head.right.val if self.len else -1

    def getRear(self) -> int:
        return self.tail.left.val if self.len else -1

    def isEmpty(self) -> bool:
        return self.len == 0

    def isFull(self) -> bool:
        return self.len == self.k

```

## 23. kê°œ ì •ë ¬ ë¦¬ìŠ¤íŠ¸ ë³‘í•©

- ë¬¸ì œëŠ” ì•ì„  "21. ë‘ ì •ë ¬ ë¦¬ìŠ¤íŠ¸ì˜ ë³‘í•©" ê³¼ ë¹„ìŠ·í•œ ëŠë‚Œì´ê¸´ í•¨
  - > ê·¼ë° ê·¸ê±´ listê°€ ë‘ê°œë¼ ì¬ê·€ë¡œ ê°€ëŠ¥í•œê±° ê°™ê³ ?
- ë‚´ ìƒê°ìœ¼ë¡œëŠ” ê·¸ëƒ¥ 3ê°œ ë¦¬ìŠ¤íŠ¸ ì•ë…¸ë“œ ë¹„êµ í•´ê°€ë©° í¬ì¸í„° ì˜®ê¸°ë©´ì„œ í’€ë©´ ë ê±° ê°™ì€ë°..
  - > ì´ê²½ìš° ìˆ˜í–‰ì‹œê°„ O(n) ì„.
- ã……ã…‚. ìš°ì„ ìˆœìœ„íë¡œ í•˜ë‹ˆ ë§¤ìš° ì‰½ë„¤.
  - ì´í•´ëŠ” ì•½ê°„ ì–´ë ¤ìš´ë°, ì¼ë‹¨ ë‚´ ìƒê°ì´ë‘ ë¹„ìŠ·í•œ ë…¼ë¦¬ë¡œ ëŒê²Œë¨
  - > ê·¼ë° ìˆ˜í–‰ì‹œê°„ì€? O(n logn) * n ì•„ë‹Œê°€? ë¬¼ë¡  í™ì´ë¼ ì´ê²ƒë³´ë‹¨ ë‚«ê² ì§€ë§Œ( ì •ë ¬ë˜ì–´ ìˆê¸°ë„ í•˜ê³ ..)
  - > heappush ëŠ” O(logN)  ì„ ì¦‰ ëŒ€ì¶© O(n logn) ì¸ë“¯ ì „ì²´ ìˆ˜í–‰ ì‹œê°„

- í’€ì´ 1. ìš°ì„ ìˆœìœ„ íë¥¼ ì´ìš©í•œ ë¦¬ìŠ¤íŠ¸ ë³‘í•©

```python
import heapq
from typing import List


# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        root = result = ListNode(None)
        heap = [] # íŠœí”Œì´ ì €ì¥ë¨

        # ê° ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ ë£¨íŠ¸ë¥¼ í™ì— ì €ì¥
        for i in range(len(lists)):
            if lists[i]:
                heapq.heappush(heap, (lists[i].val, i, lists[i])) # íŠœí”Œì˜ ë§¨ ì• ìš”ì†Œë¥¼ ê¸°ì¤€ìœ¼ë¡œ í™ì— ì •ë ¬ë¨

        # í™ ì¶”ì¶œ ì´í›„ ë‹¤ìŒ ë…¸ë“œëŠ” ë‹¤ì‹œ ì €ì¥
        while heap:
            node = heapq.heappop(heap) # ê°€ì¥ ì‘ì€ê²Œ ì¶”ì¶œë¨
            idx = node[1] # í˜„ì¬ ë…¸ë“œì˜ index
            result.next = node[2] # í•´ë‹¹ ë…¸ë“œë¥¼ reusltì— ì¶”ê°€

            result = result.next
            if result.next: # ì¶”ì¶œ ë…¸ë“œì˜ ë’¤ì— ê°’ì´ ìˆë‹¤ë©´
                heapq.heappush(heap, (result.next.val, idx, result.next)) # ì¬ì •ë ¬ë¨

        return root.next

```

- heapq
  - <https://www.daleseo.com/python-heapq/> ğŸ‘
  - ì´ê±° ë‚´ìƒê°ì´ë‘ì€ ì‚¬ìš©ë²•ì´ ë‹¤ë¦„.

ìš°ì„ ìˆœìœ„ í ë¬¸ì œë“¤ì€ ì‚¬ì‹¤ í™ë¬¸ì œë“¤ì´ë‘ ì¤‘ë³µë¨. ë”°ë¼ì„œ í™(15ì¥)ì—ì„œ ë‹¤ë¥¸ ìš°ì„ ìˆœìœ„ í í’€ì´í•´ ë³¸ë‹¤.
í™ íŠ¹ì§•ì•Œì•„ì•¼ í• ë“¯ ğŸ‘
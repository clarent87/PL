# 11장. 해시 테이블

- 280p 해시 기본 개념
  - 다 아는 내용

- 생일문제
  - 해시 충돌이 얼마나 많이 발생할까? -> 생각보다 빈번함
  - > 여기서는 수학이 아닌 프로그래밍을 통해 23명만 있으면 생일이 같은 사람들이 존재할 확률이 50%가 넘음을 보임
- 비둘기집원리
  - n개의 아이템을 m개의 컨테이너에 넣을때, n>m 이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어 있다는 원리
    - > 당연한말
- 로드 팩터
  - 해시 테이블에 저장된 데이터 개수 n을 버킷 갯수 k로 나눈것
    - > 총 버킷 갯수 말하는건가? 버킷 갯수는 해시 함수에 따라 다를수 있음? 그말 같은데
    - > 이를 테면 해시 함수 결과가 0/1이면 버킷은 두개밖에 없으니까..
  - 로드 팩터 비율에 따라 해시 함수를 재작성해야 될찌, 해시 테이블 크기를 조절해야 할지 결정
    - > 해시 함수를 재작성 ? 위 내용을 보면 좀 이해됨 -> 아닌거 같기도..
  - 이 값은 해시 함수가 키들을 잘 분산해 주는지 말하는 효율성 측정에도 사용
    - > ? 위 내용을 보면 좀 이해됨
  - 자바 10의 해시맵의 default 로드 팩터는 0.75
  - 일반적으로 로드 팩터가 증가할 수록 해시 테이블의 성능은 점점 감소
    - 자바 10의 경우 0.75를 넘어설 경우 동적 배열처럼 해시 테이블의 공간을 재할당
    - > ?
  - > 로드 팩터는 고정값이 아닌건가?  변동값같긴함.

- 해시 함수
  - 284p
  - 잘 이해는 안됨

- 충돌 발생시 처리 
  - 개별 체이닝
    - 해시 테이블의 기본 방식
    - 충돌 발생시 해당 버킷의 연결리스트로 충돌 data를 연결 해줌
    - 버킷의 노드는 (키, 밸류) 임
    - 이 방식이 해시 테이블 의 원형임
    - 이 경우 대부분의 탐색은 O(1) 이지만, 모든 경우 충돌이 발생했다면, 한개의 버킷에 연결리스트로 쭉 연결되었으므로
    - 이때는 O(n)이걸림. 탐색에..
    - 자바 8의 경우
      - 데이터의 개수가 많아지면, 연결리스트 대신 "레드-블랙" 트리에 저장하는 형태로 병행해 사용
        - 레드-블랙 : 자가 균형 이진 탐색 트리
  - 오픈 어드레싱
    - 충돌나면, 빈 버킷 찾아서 거기에 넣음 (즉 해시키값이랑 버킷이랑 맞지 않음)
    - 구현은 간단한데, 의외로 성능도 좋음
      - 선형 탐사 방식으로 구현
    - 단점. 클러스터링. 
    - 단점. 버킷보다 data 갯수가 많으면 채울수 없음
      - 즉 로드팩터가 일정 비율을 넘어가면. 동적 배열에서 더블링으로 새롭게 공간을 할당하듯
      - 리해싱으로 또 다른 더큰 버킷을 만들어서 거기에 옮김.
  - 289에 위 두가지 성능 비교가 있음
    - 로드팩터 0.8 언저리 까지는 오픈 어드레싱 성능이 좋음

- 파이썬의 해시 테이블은?
  - dict 임
  - 충돌 처리는?
    - 오픈 어드레싱 방식
      - 개별 체이닝하려면, 연결리스트가 필요하고 그러면 malloc을 통한 추가 메모리 할당이 필요 -> 오버헤드가 큼
      - 로드팩터는 0.66으로 둠
      - > 자바는 개별 체이닝이긴함. 

부록A - 면접관이 잘못알고 있는 사실들을 소개 👍

## 706. 해시맵 디자인
# 7장. 배열

- 추상 자료형 (ADT)의 실제 구현은, 배열 또는 연결리스트로 진행
- 예를 들어
  - 스택 : 연결리스트로 구현
  - 큐 : 배열로 구현
  - 물론 그 반대로 구현도 가능함

- 동적 배열의 등장
  - 정적 배열은 크기를 미리 알지 못하면, 공간 낭비를 하거나 부족할수 있어서.
  - > 파이썬엔 당연히 정적 배열은 없음.
  - 파이썬의 list 또는 자바의 Arraylist
  
- 동적 배열 원리
  - 간단함. 초기에 작은 값으로 공간을 잡고 다차면 늘린다.
  - 이때 기존 data를 한번 복사해야해서 O(n) 만큼 비용 걸림
  - 근데 거의 그럴일은 적으므로.. 동적 배열은 여전히 조회에 O(1)의 시간이 걸림
    - > 당연
  - 더블링 이란?
    - 동적 배열이 다차면, 크기를 늘려야 하는데 보통 2배씩 늘림
    - 파이썬의 경우 2배씩 크기를 늘리다가 후반에는 조금만 늘리나봄. 그래서 전체적으로 보면 1.125배가 Growth Factor임
      - Growth Factor -> 재할당 비율이라고 함. 크기를 원본에서 얼마나 늘릴지 나타내는것
    - 자바 ArrayList의 Growth Factor는 1.5배. c++ vector는 2배

## 1. 두수의 합

- 풀이 1
  - 브루트 포스
    - O(n^2) 걸림. for 루프 두개 니까

    ```python
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i, j]
  
    ```

- 풀이 2
  - in을 이용한 탐색
    - O(n^2) 걸림. list의 in 연산이 O(n)이니까
    - 하지만 파이썬의 in연산이 매우 빠르기 때문에 브루트 포스보다 나음

    ```python
    def twoSum(self, nums: List[int], target: int) -> List[int]:
            for i, n in enumerate(nums):
                complement = target - n

                if complement in nums[i + 1:]:
                    return [nums.index(n), nums[i + 1:].index(complement) + (i + 1)] # 슬라이싱을 한거라서 index는 원본 list에 맞추어 보정 필요
    
    ```

- 풀이 3
  - 해시 이용
    - O(n)임 for문 하나라서. 물론 해시는 충돌나면 버켓을 이용해야 해서 최악의 경우 O(n) 이긴하지만, 보통 O(1)

    ```python
        def twoSum(self, nums: List[int], target: int) -> List[int]:
        nums_map = {}

        # 인덱스와 값을 바꿔서 딕셔너리로 저장
        # 즉, 키:값, value:인덱스 -> 추후에 return은 index로 해야 하기 때문
        for i, num in enumerate(nums):
            nums_map[num] = i

        # 타겟에서 첫 번째 수를 뺀 결과를 키로 조회
        for i, num in enumerate(nums):
            # i != nums_map[target - num] 는 현재 index의 수면 안되기 때문 -> 문제 조건이 같은 수를 이용할수 없음
            if target - num in nums_map and i != nums_map[target - num]:
                return [i, nums_map[target - num]]
    
    ```

- 풀이 4
  - 풀이 3의 for 두개를 하나로 만듬. 성능 차이는 없음. 코드만 간결해짐

  ```python
      def twoSum(self, nums: List[int], target: int) -> List[int]:
        nums_map = {}
        
        # 하나의 `for`문으로 통합
        # 이게 가능한 이유
        # 두수 A,B가 배열에 순서대로 있고 A+B 가 target인경우
        # 7-3은 A를 기준으로 B를 해시에서 찾는거인데
        # 여기꺼는 B를 기준으로 A를 해시에서 찾는것.
        # 즉 i가 A일때는 아직 해시 테이블에 B가 없어서 정답을 못찾지만
        # i가 B일때는 A가 해시에 있어서 정답이 찾아짐
        for i, num in enumerate(nums):
            if target - num in nums_map:
                return [nums_map[target - num], i]
            nums_map[num] = i
  
  ```

- 풀이 5
  - 투포인터 전략.
    - 근데 이거 쓰려면 정렬을 해야 하는데, 그러면 index가 날아가서 문제를 풀수가 없다.
    - > 전략 자체는 참신

    ```python
        def twoSum(self, nums: List[int], target: int) -> List[int]:
        left, right = 0, len(nums) - 1 # 파이썬의 다중 할당
        while not left == right: # not 연산만 볼만함
            # 합이 타겟보다 크면 오른쪽 포인터를 왼쪽으로
            if nums[left] + nums[right] < target:
                left += 1
            # 합이 타겟보다 작으면 왼쪽 포인터를 오른쪽으로
            elif nums[left] + nums[right] > target:
                right -= 1
            else:
                return [left, right]
    
    ```

## 42. 빗물 트래핑

이것도 보니까 회사에서 나온 문제 였긴 하네..
문제 난이도가 있는거 였네. ( 리트코드 하드 문제)

- 풀이 1. 투포인터 이용
  - 이해하는데 쫌 걸림
  - 생각을 잘해야하는데
    - 왼쪽을 기준으로 보면, 물을 채우는것은 왼쪽에서 가장큰 높이을 만나고 이후 애들이 채워지는것
    - 오른쪽도 마찬가지..
    - > 말로 쓰니 애매한데, 이거 나는 첨음에 잘못생각햇음

  ```python
      def trap(self, height: List[int]) -> int:
        if not height:
            return 0

        volume = 0
        left, right = 0, len(height) - 1  # 인덱스 뽑음
        left_max, right_max = height[left], height[right]  # 각 맨 끝에서 시작

        while left < right:  # 오른쪽 인덱스가 왼쪽 인덱스보다 클때까지 진행
            left_max, right_max = max(height[left], left_max), max(height[right], right_max)
            
            # 더 높은 쪽을 향해 투 포인터 이동            
            if left_max <= right_max:
                volume += left_max - height[left]
                left += 1
            else:
                volume += right_max - height[right]
                right -= 1
                
        return volume
  ```

- 풀이2. 스택 쌓기
  - 스택
    - filo 였음. 큐는 fifo
  - > 이해 안됨. 넘어감

## 15. 세수 합

- 풀이 1. 브루트 포스
  - 인덱스 이해가 난해 했음
  - 수행시간 O(n^3) 즉. 문제 안풀림

    ```python
        def threeSum(self, nums: List[int]) -> List[List[int]]:
            results = []
            nums.sort()

            # 브루트 포스 n^3 반복
            for i in range(len(nums) - 2): # range(5)는 0,1,2,3,4 임

                # 중복된 값 건너뛰기
                if i > 0 and nums[i] == nums[i - 1]: # 앞전 값이랑 같으면 건너뛰어야함. 문제 조건을 보면 뛰어야하는걸 알수 있음
                    continue
                for j in range(i + 1, len(nums) - 1):
                    if j > i + 1 and nums[j] == nums[j - 1]:
                        continue
                    for k in range(j + 1, len(nums)):
                        if k > j + 1 and nums[k] == nums[k - 1]:
                            continue
                        if nums[i] + nums[j] + nums[k] == 0:
                            results.append([nums[i], nums[j], nums[k]])

            return results
    ```

- 풀이 2. 투 포인터로 합계산
  - 수행시간 목표 O(n^2)
  - 풀이 원리는 이해가 감. 코드도 대충 이해감

- 투포인터 기법이란? 👍
  - 일반적으로 시작점, 끝점에서 두개의 포인트로 좁혀나가는 방식
  - 정렬된 배열에서 쓰는게 좋다
  - 추후 슬라이딩 윈도우와 공통점, 차이점을 비교해 준다.


## 561. 배열 파티션

- 문제가 이해하기 어려워서 그렇지, 원리 이해하면 쉽다 코드도 단순

```python
    def arrayPairSum(self, nums: List[int]) -> int:
        return sum(sorted(nums)[::2]) # [::2] step이 2즉, 0,2,4,6~ index의 값으로 list가 만들어짐.
```

# 자주 사용될 문법/라이브러리 정리

## 문법

- range, enumerate
  - range(10)은 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 숫자를 생성한다.
  - range(1, 11)은 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 숫자를 생성
  - range(len(nums) - 1, 0 - 1, -1) 이렇게 param 세계 줄수 있음 마지막은 step
  - enumerate(iterable) 하면 index, value를 내줌

- max()/min()
  - <https://velog.io/@kjy5947/python-max함수의-key>변수-사용
  - `str = max(arr,key = lambda x:x[1])`
    - key 변수가 중요. 람다 넣을수 있음. key가 비교할 값을 나타냄. 물론 비교할때 쓰는 값이 그렇다는거고 결과는 arr에 있는 요소를 반환

    ```python

    test_dict ={
        "A": 2,
        "B": 1,
        "C": 3,
    }

    print(max(test_dict, key=test_dict.get))
    # C 출력됨

    ```

  - max(iterable, *[, key, default]) : 이렇게 iterable만 target으로 줘도 되고
  - max(arg1, arg2, *args[, key]) : 아니면 arg 여러개를 target으로 줘도 된다.

- sorted()
  - sorted() 함수는 정렬 된 시퀀스 (list, tuple, string) 또는 정렬 된 컬렉션 (sets, dictionary)을 목록 형식으로 반환하는 Python의 내장 함수
  - 새로운 시퀀스를 생성해 낸다. 
    - > 시퀀스.sort()는 해당 자료형 안에서 정렬
  - param으로 시퀀스 자료형 넣으면되는데
  - return은 정렬된 `요소`의 **list임**
  - 문자열 sort는 sorted 함수를 이용하고, 이후 `"".join(str)` 로 문자열을 list에서 합쳐줘야함 👍
  - key param을 줄수 있고 이걸로, 정렬을 위한 키 또는 함수를 전달 할수 있음
    - > list에 있는 sort 처럼 key 에 람다 주고 람다 return은 튜플로도 가능

- 나눗셈
  - `//` 파이썬 3.7에서는 몫은 이걸로 구해야 함
  - `/` 는 float 값을 반환
  - `%` 는 나머지
  - `divmod()`가 나머지와 몫을 한번에 받는것.
    - 예시 `carry, val = divmod(sum + carry, 10)` => sum + carry를 10으로 나눔
    - divmod는 작은 숫자를 다룰 때는 a//b, a%b 보다 느립니다. 대신, 큰 숫자를 다룰 때는 전자가 후자보다 더 빠르지요.

- f-string
  - 디버깅을 위해 print를 사용해야 할텐데, 이떄 쓰면 좋음
  - `print({f'{idx+1}:{fruit}')` 이런식으로 변수를 직접 쓸수 있음

- class method 내부의 로컬 변수 출력
  - 로컬 변수 출력이고, ide 사용 못하면 사용할만 한듯

    ```python
    import pprint # dict 를 출력할떄 예쁘개 출력 해줌
    pprint.pprint(local())

    ```

- is vs ==
  - is 는 id()값 즉 주소값 비교
  - == 는 실제 값 비교

- 문자열
  - isalnum : 문자열이 알파벳([a-zA-Z])과 숫자([0-9])로만 구성되었는지 확인하는 파이썬 문자열 메소드
  - lower : 문자열을 lower case로 변환
  - isdigit : 문자열이 숫자 인지 판단
  - split
    - <https://docs.python.org/ko/3/library/stdtypes.html?highlight=split>
    - sep param이 없으면 공백 등으로 문자열을 분할
    - 반환은 list이다

- list
  - append, remove, del
  - [::-1] : 값 뒤집는다. 슬라이싱 류.
  - s[:999] : 즉 list의 길이 보다 더 크게 index를 주면? 잘 동작함 이거나 [:]나 같게됨
  - list.sort(key=)
    - sorted랑 다르게, 제자리 정렬 이었음.
    - tim 소트. 내부적으로..
    - key에 람다를 넣는데 return을 튜플로 해서, 여러 조건을 줄수가 있음 ( 937. 로그파일 재정렬) 👍
      - > 람다의 return을 tuple로 준다는 얘기이고, 이러면 튜플의 첫번쨰 요소가 main 정렬 기준, 두번째가 두번째 정렬 기준이 된다.
    - <https://dailyheumsi.tistory.com/67>
    - 그리고 반환값은 None임.
      - > in place sort라 반환이 없음
  - 슬라이싱 예시 중요 144p
    - S[:] : 사본을 만들어서 return. 문자열이나 리스트를 복사하는 파이썬 다운 방식
  - list간 + 연산
    - 리스트 두개를 연결해 준다.
  - index(값)
    - 값에 해당한는 index 반환
    - index 연산자는 가장 작은 index를 반환함 (즉, 찾자마자 반환인듯.. )
      - > 즉 해당 시퀀스에 중복된 다른 값의 위치가 있을수 있음

- dict
  - for
    - 기본적으로 for문에 dict 변수를 넣어서 돌리면 key만 추출됨
  - keys()
  - values()
    - <https://velog.io/@langssi/Python-Dictionary#dict_keys-dict_values-dict_items>
    - values(), keys(), items()함수의 경우 py3 부터 list를 반환하지 않고 특별한 객체를 반환함
  - items() 👍
    - `key : value` 를 for문으로 받을수 있음
    - key와 value를 한꺼번에 for문을 반복하려면 items() 를 사용합니다.
  - get(key)
    - 해당 키에 대한 값 추출
    - dict[key] 도 가능하지..
    - 위와 차이는 dict[key] 의 경우 해당하는 값이 없으면, keyError
    - get의 경우 None을 반환해줌

- 👍 최대값, 최소값을 초기화 하는 방법이 중요함
  - `mx = -sys.maxsize`,  `mn = sys.maxsize`
    - 또는 `mx = float('-inf')`, `mn = float('inf')` 가능
  - 최대값에는 가장 작은 값으로 초기화를 해야, 나중에 값을 비교해가며 교체해서 최대값을 찾을수 있음
  - 최소값도 동일
  - 대부분 코테에서는 값의 min,max를 주니까 이걸로 최대,최소값의 초기값을 세팅해도 됨

- 다중 할당
  - `rev, rev.next, slow = slow, rev, slow.next` 를 아래 두줄로 쓰면 전혀 다른 결과가 나옴
    - `rev, rev.next = slow, rev`  
    - `slow = slow.next` # 현재 rev는 slow이므로.. 이거 통과하면 rev값이 변함.
    - 다중 할당은 작업이 동시에 일어난다는 특징 중요

- 👍 파이썬 지수 연산
  - `print(5**6)` 5^6을 말함

- map()
  - map(f, iterable)

  ```python
  a = [1.2, 2.5, 3.7, 4.6]
  a = list(map(int, a)) # 이렇게 list에 요소들에 int를 적용할수 있음
  # a = [1, 2, 3, 4]

  ```

- set
  - <https://wikidocs.net/1015>
  - 모르고 있었는데, set에는 list를 넣을수가 없다. 왜냐면 list를 넣으면 list가 가변이기 때문.
  - set 자체는 불변 data는 아님
  - `a = set()`
  - `a = {1,2,3}` // 초기값있을떄 이렇게 할수 있음
    - `a = {}` 이건 set이 아니라 dict임. 주의 필요
  - 그리고 set은 입력 순서 유지 안됨
  - sorted..가능.
  - remove(값)
    - 해당 값을 제거
  - add(값)
    - 값을 set에 넣음

- `answer = [0] * len(T)`
  - 배열의 * 연산

- 제너레이터 익스프레션

  ```python
      def numJewelsInStones(self, J: str, S: str) -> int:
          # return sum([s in J for s in S]) 리스트 컴프리헨션의 []는 제거 가능
          # https://peps.python.org/pep-0289/
          # generator expression인데 나도 정리 했었음.
          return sum(s in J for s in S) # s in j는 True, Flase로 반환 즉, true, flase list인데 true는 1, false는 0 이므로 이걸 더해서 값이 나옴
  ```

- zip  👍 👍
  - 2개 이상의 시퀀스를 대상으로 새로운 튜플 시퀀스를 만듬
    - 근데 보니까 1개의 시퀀스를 넘겨도 됨.
    - 그럼 `[(1,),(2,)]` 처럼 나옴
  - 이떄 2이 이상의 시퀀스들의 len이 다르면 짧은 길이를 기준으로 만든다.
  - python 2에서는 zip의 결과는 list이지만, python 3에서는 제너레이터를 return
  - 제너레이터로 list 만드는 것은 list에 다시 한번 넣는것!

  ```python

  numbers = (1, 2, 3)
  letters = ("A", "B", "C")
  a,b,c = zip(numbers, letters) # 다중 할당은 반드시 zip으로 만들어진 튜플 갯수랑 맞아야 함. 물론 ... 이런건 test안함
                                # 그냥 변수로 받으면 zip class이므로 list로 넘겨야 list로 만들어짐.
  print(a)

  ```

- 패킹, 언패킹
  - `*` 하나로는 list 같은거 언패킹 ( 언패킹은 함수의 파라메터로 넘길때 쓰는것)
  - 패킹은 함수 파람정의에 쓰면 패킹됨
  - 변수 할당에도 사용가능 (아래 둘다 가능)
    - a, *b = [1,2,3,4]
    - *a, b = [1,2,3,4]
  - `**`처럼 두개 짜리는 dict 언패킹/패킹용

- 무한대 표시

  ```python
  min = float('inf')

  ```

## 라이브러리

### heapq

- `heapq.heappush(freqs_heap, (-freqs[f], f))`
  - heap 사용법 위와같음. 값은 튜플도 넣을수 있는데, heap만들땐 튜플의 0번째 index 요소를 기준으로 만듬

- heappush vs heapify
  - heapify의 경우 list에 값들을 전부 대충 넣고, heapify로 정렬하는것
  - heappush는 하나씩 요소를 넣고 정렬
    - 내부적으로는 매번 heapify를 호출
    - 이 방식이 원래 힙의 삽입 방식
- 파이썬은 최소 힙만 지원

### collections.Counter(nums)

dict 류중 하나, nums list를 주면 요소를 key로 값은 요소 갯수로 해서 dict 만들어줌

- `collections.Counter(nums).most_common(k)`
  - 빈도가 높은 순으로 아이템을 추출해줌. k개
  - 당연 key:value 튜플 list로 나옴

### deque

- 동적 배열로 구성된 리스트는 맨 앞 아이템을 가져오기에 적합한 자료형이 아님. 👍
- 왜냐면 척 값을 꺼내오면 모든 값이 한칸씩 시프팅 됨 -> O(N)
- 그래서 이럴땐 deque를 사용

```python
import collections
from typing import Deque
strs: Deque = collections.deque() # list를 큐로 쓸꺼면 deque 쓰는게 좋음
strs.popleft() != strs.pop(): # pop은 list 의 pop처럼 오른쪽 즉, 맨 마지막에 들어간 요소를 빼는것
```

### defaultdict

- 일반 dict의 경우 없는 index에 접근하면 keyerror 발생
  - 근데 defaultdict의 경우 없는 index에 접근하면 키:값을 생성해줌.
  - 이때 `anagrams = collections.defaultdict(list) # list를 요소로 같는 dict를 만듬` 이런식으로 param을 줘야하는데
  - param의 의미는 값의 type을 나타냄. 즉 값을 넣어줄때 해당 값 type의 default 값을 넣어줌

### 정규식

### functools

- `functools.reduce(lambda x,y : 10*x+y, a, 0)`
- reduce(집계 함수, 순회 가능한 데이터[, 초기값])
- functools는 함수를 다루는 함수를 뜻함
- reduce는 자바와 같은 의미, 두 인수의 함수를 누적 적용하라는 메소드
- 예시
  - `functools.reduce(lambda x,y : x+y, [1,2,3,4,5])`
  - (((1+2) +3 ) +4 ) + 5 임

- 또는, 아래 처럼 operator 모듈 활용 가능

  ```python
  from operator import add, mul
  functools.reduce(add, [1,2,3,4,5])
  ```

## 외워둬야 할것

### 알고리즘 빅오

O(1) -> O(logn) -> O(n) -> O(nlogn) -> O(n^2) -> O(2^n) -> O(n!)

### 스택

- `while stack and cur > T[stack[-1]]:` 이런식의 구문..
  - 현재 값이랑 스택의 마지막값을 인덱스로해서 T에서 값을 받아서 비교..

### 큐

- 스택에 비해서 적을쁜, 우선순위큐나, deque는 여러분야에서 유용하게 쓰인다.
  - BFS(너비 우선 탐색) 이나 캐시 등 구현에 씀

- 나은 성능을 위해서는 deque를 쓰는게 좋다.
  - 양방향 삽입 삭제가 모두 O(1)에 가능한것이 장점

- 큐나 스택의 AD를 알아 두는게 좋음
  - 스택 : push, pop
  - 큐
    - enqueue : 큐 rear에 값 추가
    - dequeue : 큐 front에서 값 꺼냄

- 우선순위 큐
  - heapq로 만드는게 정석 (python 우선순위큐가 있지만.. 안씀 GIL때문)
  - <https://www.daleseo.com/python-heapq/>
    - 사용법 중요! 특히 응용-최대힙

### 연결리스트

- 생성 ( 앞쪽에 노드 추가)
  - 연결리스트의 팰린드 룸에서 가져옴

  ```python
    class ListNode:
        def __init__(self, x):
            self.val = x
            self.next = None

    def isPalindrome(self, head: ListNode) -> bool:
        rev = None
        slow = fast = head

        # 런너를 이용해 역순 연결 리스트 구성
        # slow는 1 -> 2 -> 3 이런순
        # rev 는 2- > 1 -> none 이런순으로 앞쪽에 node가 추가됨
        while fast and fast.next:
            fast = fast.next.next
            rev, rev.next, slow = slow, rev, slow.next # 파이썬 다중 할당 ( 이부분 생각하기가 어렵겠네..)
  ```

- 연결리스트 뒤집기
  - 재귀 및 반복 방식이 있음
  - `206. 역순 연결 리스트`  참조

- `root = start = ListNode(None)`
  - 문제 풀이 중에 이런식으로 따로 head앞에 노드를 만들어서 진행하는 case가 있음
  - 홀짝 연결리스트, 역순 연결리스트 문제.

### 백트래킹 개념

- `21. 두 정렬 리스트의 병합` 참조

### full adder 구현

- `2. 두수의 덧셈` 참조
  - > input은 숫자 역순 연결 리스트임

## 기타

- 제너레이터 vs iterable
  - > iterable이 제너레이터는 아니었던거 같음

- 변수 스왑
  - 파이썬에서는 temp없이 바로 스왑가능 => `l1, l2 = l2, l1`
  - temp없이 수학적 스왑도 가능
    - x = 9, y = 4 일때
      - x += y // x는 y만큼 증가
      - y = x - y // x에 y만큼 감소 즉 원본 x
      - x -=y // x에 원본 x만큼 감소 즉 y

# 1부 및 2부(파이썬)

## 1장

- 해커랭크에서 연습 필요
  - > 쿠팡은 해커랭크를 화면 공유용으로 쓰긴함
  - IDE괜찮은지 확인 필요 및 제공하는 import 모듈이 뭐가 있는지도 확인 필요

- 문제 풀고 제출할땐, 풀이를 잘 정제하는게 좋다. ( 면접관이 코드도 본다.)
- 연습장 및 필기도구로 적어가며 풀이하는게 좋다
- 자신만의 코드 스니펫을 구비해 주는것이 좋다.
  - 연결리스트를 뒤집거나 삭제하는 등의 작업

- 파이썬은 c++보다 느려서 같은 알고리즘이라도 테스트케이스 통과 못하는 경우가 많다.
  - 따라서 알고리즘 최적화가 중요

- 예외 처리 중요
  - 예외 처리는 상단에 먼저 해두고 진행하는 것도 좋다 ( 입력값 null check. 등)

- 문제 풀이는 시간을 두고 풀고, 안풀리면 넘어가는 것이 좋다.
  - 최대한 풀수있는 문제는 다 풀기 위함

- REPL 환경을 잘 이용해야 한다.
  - 코테는 TDD 방식이 안되니까..
  - REPL은 read-eval-print-loop를 의미하는데 쉽게 쥬피터 노트북 생각하면된다

## 2장

- python 3.7 이후 dataclass decorator 지원
  - 이걸 타입 힌트와 함께 활용하면 class를 구조체 형태로 정의 가능 - 62p
    - > 타입 힌트 는 pep 484에 나온건데 python 3.5 이상부터 지원. 이거 잘 알아 둬야 할듯.
  - dataclass는 초기화 함수 및 출력도 읽기 편하게 출력 해준다고 함

- 클래스는 코테에서는 잘 쓰지 않는다.
- 파이썬이 코딩 면접에 유리한 이유
  - 언어가 쉬워서 면접관이 파이썬 잘 몰라도 설명 가능
    - c++은 모르는 면접관들이 있다.
  - 언어에서 제공하는 기능이 풍부함
    - c는 아예 없어서 라이브러리를 import하지 않는이상 답이 없음..

- 여담
  - 개발시, 자바는 apache commons 나 guava같은 라이브러리 쓰는게 좋다.
  - 아마 spring은 제공하는 utils를 이용하는게 좋을듯.

## 3장 파이썬 (3.7기준)

- 인덴트
  - pep8 기준 공백 4칸이 원칙

- 네이밍 컨벤션
  - java랑은 다르게 snake_case가 원칙

- 타입힌트는 써주는게 좋다.
  - 타입힌트는 타입을 강제하는 기능은 아니다.
    - > 당연
  - 근데 보통 코테에서는 알고리즘이 짧아서 이게 필요 없기는 하지만, 코드 정리시에는 추가하는게 면접관에제 좋은 점수를 받는다.
  - 온라인 코테에서는 `pip install mypy` 사용하면 된다네. 80p
    - > 이거는 타입 힌트에 오류가 없는지 자동으로 확인해주는 기능을 가짐

- 리스트 컴프리헨션
  - 기존 리스트를기반으로 새로운 리스트를 만드는 구문
  - map, filter 를 python에서 제공하지만, 이거 대신 쓰는거 추천 ( effective python에도 나온 내용)
    - > 가독성이 좋기 떄문
  - 파이썬 2.7 이후에서는 list 뿐만아니라 dict도 컴프리헨션 가능 👍
    - `a = {key : value for key, value in original.items()}` # key : value에 값이 들어감
  - 표현식은 2개 이상이 넘지 않아야 한다. (가독성 떄문)

- 제너레이터 84p
  - 대표 함수 : range
    - python 2에서는 xrange가 제너레이터 이용한 함수 였음
  - > 제너레이터 동작은 따로 정리한거 보면 좋음. 이거 생각보단 복잡했음
  - 제너레이터에 index operation도 가능 👍
  - 메모리 점유율에 유리 하니까. 권장하는듯.
    - 리스트 컴프리헨션은 메모리에 만든 내용들을 가지고 잇음
    - 제너레이터는 그때 그때 만듬.

- enumerate
  - 인덱스 자동 부여

- 나눗셈(86p) 👍
  - 파이썬 3 이상
    - `/` ,`//` 두가지가 다름 
      - `5//3` 은 `int(5/3)`과 같음. 즉 몫만 가져오는것
    - 나머지 연산은 %
  - 몫 나머지 동시 연산은 divmod() 함수 써야함

- print  (87p)
  - f-string 밑 기타 디버깅에 도움되는 내용 있음
  - f-string은 3.6 이상에서만 가능

- locals() : 90p
  - > 디버깅에 도움 된다는데..

- 클린코드에서는 주석은 없는게 좋다고 했으나, java외 다른 언어에서는 논란의 여지가 있음
  - > 코딩 인터뷰에서는 주석 있는게 좋음

- 구글 파이썬 가이드 :95p 👍
  - > 한번 봐 둘것

## 4장 빅오, 자료형

- 빅오 정리 :101p
  - O(1)
    - 해시 테이블의 조회 및 삽입
  - O(log n)
    - 이진 검색
  - O(n)
    - linear-time 알고리즘
    - 정렬되지 않은 List에서 최소값, 최대값 찾는거.. 이값을 찾으려면 모든 값을 최소 1번은 봐야함
  - O(n logn)
    - 병합 정렬 등, 대부분의 효율좋은 알고리즘들이 여기에 해당
    - 적어도 모든 수를 한번은 비교해야하는, 비교기반 정렬 알고리즘은 이거보다 빠를수는 없음. 아무리 좋은 알고리즘이어도..
      - 물론 입력값이 최선인경우 비교를 건너뛰어서 O(n)이 가능 => timsort가 그러함
  - O(n^2)
    - 버블 정렬같은 비효율적 알고리즘들.
  - O(2^n)
    - 피보나치수 재귀 계산
  - O(n!)
    - 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제 (TSP문제) 를 브루트 포스로 풀면 여기에 해당

- 메모리 사용량과 알고리즘 속도는 트레이드 오프 관계, 보통 둘다 좋을수는 없다. 
- 최근에는 병렬처리가 가능한 알고리즘이냐 아니냐가 좋은 알고리즘의 척도가 되기도 함

- 파이썬 자료형 
  - 107p 계층 구조 볼만함.
  - 파이썬은 2와 3이 자료형에 차이가 조금 있다. 

- 숫자
  - 2에서는 int,long
    - Fixed-precision, and Arbitrary-precision
  - 2.4에서는 int쓰다 부족하면 자동으로 long이 되었음
  - 3부터는 Int만 존재
    - 단, int가 arbitrary-precision임
    - > 자세한것은 109p. java bigintiger가 임의 정밀도.
  - bool 은 Int의 서브 클래스
    - 내부적으로 1과 0으로 처리됨
    - `Ture == 1` 값은 True가 나옴
  - int는 object의 하위 클래스
- 매핑
  - 딕셔너리
    - > python 3.7인가 거기서 부터 입력 순서가 유지 됨.
- 집합
  - set
    - 모르고 있었는데, set에는 list를 넣을수가 없다. 왜냐면 list를 넣으면 list가 가변이기 때문.
    - set 자체는 불변 data는 아님
    - `a = set()`
    - `a = {1,2,3}` // 초기값있을떄 이렇게 할수 있음
      - `a = {}` 이건 set이 아니라 dict임. 주의 필요
    - 그리고 set은 입력 순서 유지 안됨
    - > set 연산은 따로 확인 필요할듯. 
- 시퀀스
  - str, bytes, tuple => imutable
    - > 튜플은 입력 순서 보장 되나봄
  - list => mutable
- is vs ==
  - is 는 id()값 즉 주소값 비교
  - == 는 실제 값 비교

- 파이썬의 모든 자료형은 객체임.
  - 자바의 primitive type 말고 boxing된 객체 타입 있는거.. 그거라고 보면됨
 
- 119p 파이썬 정수형 구조 신기.

## 5장. 리스트, 딕셔너리

이거 두개는 코테 모든 문제에 쓰임
  
> 아.. 책내용 진짜 괜찮네..

- 리스트 123p
  - 내부적으로 동적 배열로 구성됨
    - > 자바 ArrayList 같은거
    - > 내부적으로는 객체들의 포인터를 배열로 관리.-> 연결리스트 + 배열 같은 느낌
  - 입력 순서 유지됨
  - 스택, 큐 연산 모두 지원
    - 스택 연산은 보통 O(1)
    - 큐 연산은 O(n)따라서 큐 연산을 위주로 쓸꺼면 deque를 쓴는게 좋다.
  - IndexError
    - 없는 index 접근시 발생
  - 주요 연산
    - len(a) : O(1)
    - a.pop() : 이건 스택연산. O(1). 리스트의 마지막 요소 추출
      - > 리스트 메서드들은 리스트를 스택으로 사용하기 쉽게 만드는데, 마지막에 넣은 요소가 처음으로 꺼내지는 요소입니다
      - > https://docs.python.org/ko/3/tutorial/datastructures.html
        - 책 내용이 여기 내용 복붙같네..
    - a.pop(0) : 이건 큐 연산. O(n) -> 리스트 첫번째 요소 추출하는거는 맞는데, 이건 전체 복사가 필요하다고 함 그래서 O(n)
      - > 0 대신 다른 index를 넣으면 해당 요소 빼줌.
      - >  리스트의 끝에 덧붙이거나, 끝에서 꺼내는 것은 빠르지만, 리스트의 머리에 덧붙이거나 머리에서 꺼내는 것은 느립니다 (다른 요소들을 모두 한 칸씩 이동시켜야 하기 때문입니다
      - > 큐를 구현하려면, 양 끝에서의 덧붙이기와 꺼내기가 모두 빠르도록 설계된 collections.deque 를 사용하세요
    - a.sort() : Timsort 최선의 경우 O(n) 도 가능 보통 O(n logn)
      - > 그리고 이거는 제자리 정렬임. 즉 따로 추가 공간이 필요없음 155p
      - > 그리고 기본적으로 오름차순 정렬임.
    - a.reverse() : O(n) 이거 list에만 제공됨. str에는 없음
    - elem in a : O(n)
    - 슬라이싱
      - O(k) k는 슬라이싱할 요소 갯수
      - https://robotai.tistory.com/27
      - 슬라이싱은 새로운 객체를 만들어 내는것
      - 슬라이싱은 원래 문자열에 유용하게 활용되는 기술
    - 기타
      - remove(value) : 리스트안에서 해당 item의 index번호를 리턴, 없는 경우 ValueError
      - index(value) : value 요소의 인덱스 리턴. 찾을 아이템이 없으면 ValueError 발생 O(n)
      - insert(index, value) : 특정 위치에 값을 넣을수 있음 ( 아마 O(n)이겠지?)
    - > 리스트의 경우 정렬되어 있다면 탐색시 이진 검색이 효과적 ( 순차 탐색은 O(n)이기 때문..)

- 딕셔너리
  - python 3.7 부터는 입력순서 유지됨
    - 다만 여전히 3.6 이하를 사용하는 곳이 많으니, 항상 이럴꺼라고 생각하면 안됨
    - 이땐, collectins.OrderedDict()를 써야함
    - > 코테에서 인터프리터 버전을 확인할수 있으면 확인하고 진행하는것이 좋을듯
  - 내부적으로는 해시테이블로 만들어짐
    - 해시 테이블 원리
      - https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table해시-해싱-해시테이블-자료구조의-이해-6ijyonph6o
  - 해시만 가능하면 어떤 type이던지 key로 사용할수 있음. 단 불변객체여야하고.
  - 대부분의 연산은 O(1) 복잡도.
    - `key in a` -> key가 dict a에 있는지 확인하는거. 이것도 당연히 O(1)
  - 3.6이상부터는 dict의 메모리 사용량도 20%정도 감소 되었음 -> 성능 개선된것
  - collections 모듈의 딕셔너리를 효율적으로 생성하는 모듈들 매우 유용하다
    - collections.defaultdict()
    - collections.Counter()
    - collections.OrderedDict()
  - keyError
    - 없는키를 접근하면 발생
    - 이거 try except로 잡아서 해당 key/value를 삽입하는등 유용하게 써먹을수 있음
    - 물론 `key in a` 처럼 키가 있는지 미리 확인하는 방법도 있음
    - list에서는 IndexError가 있었음. 비슷하게..
  - dict의 for는 key가 출력됨

- 딕셔너리 모듈
  - defaultdict 객체
    - 키가 없어도 default 값을 갔는 value를 넣어줌 (원랜 KeyError가 나야함.)
    - `a = collections.defaultdict(int)` // 이러면 int의 default값인 0이 없는 키를 조회 했을때 value로 들어감
  - Counter 객체 👍
    - `a = [1,2,3,4,5,5,5,6,6]`
    - ` b = collections.Counter(a)` 
    - b를 출력하면 다음과 같다. 
      - `Counter({5:3, 6:2, 1:1, 2:1, 3:1, 4:1})`
    - 즉 카운터 객체는 list 같은걸 받아서, key는 item, value는 해당 item이 나온횟수를 가지고 dict를 만들어 준다 
      - 물론 실제로는 dict를 한번더 wrapping한 collections.Counter 이긴함
    - Counter 객체에서 가장 빈도가 높은 요소 추출은?
      - `b.most_common(2)` param은 빈도 높은 요소 몇개 뽑을지
      - 결과는 `[(5,3),(6,2)]`
  - OrderedDict 객체
    - 3.6 이하면 쓴다. 
  - 지원하는 method
    - https://wikidocs.net/16
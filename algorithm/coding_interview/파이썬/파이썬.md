# 1부 및 2부(파이썬)

## 1장

- 해커랭크에서 연습 필요
  - > 쿠팡은 해커랭크를 화면 공유용으로 쓰긴함
  - IDE괜찮은지 확인 필요 및 제공하는 import 모듈이 뭐가 있는지도 확인 필요

- 문제 풀고 제출할땐, 풀이를 잘 정제하는게 좋다. ( 면접관이 코드도 본다.)
- 연습장 및 필기도구로 적어가며 풀이하는게 좋다
- 자신만의 코드 스니펫을 구비해 주는것이 좋다.
- 파이썬은 c++보다 느려서 같은 알고리즘이라도 테스트케이스 통과 못하는 경우가 많다.
  - 따라서 알고리즘 최적화가 중요
- 예외 처리 중요
  - 예외 처리는 상단에 먼저 해두고 진행하는 것도 좋다 ( 입력값 null check. 등)

- 문제 풀이는 시간을 두고 풀고, 안풀리면 넘어가는 것이 좋다.
  - 최대한 풀수있는 문제는 다 풀기 위함

- REPL 환경을 잘 이용해야 한다.
  - 코테는 TDD 방식이 안되니까..
  - REPL은 read-eval-print-loop를 의미하는데 쉽게 쥬피터 노트북 생각하면된다

## 2장

- python 3.7 이후 dataclass decorator 지원
  - 이걸 타입 힌트와 함께 활용하면 class를 구조체 형태로 정의 가능 - 62p
    - > 타입 힌트 는 pep 484에 나온건데 python 3.5 이상부터 지원. 이거 잘 알아 둬야 할듯.
  - dataclass는 초기화 함수 및 출력도 읽기 편하게 출력 해준다고 함

- 클래스는 코테에서는 잘 쓰지 않는다.
- 파이썬이 코딩 면접에 유리한 이유
  - 언어가 쉬워서 면접관이 파이썬 잘 몰라도 설명 가능
    - c++은 모르는 면접관들이 있다.
  - 언어에서 제공하는 기능이 풍부함
    - c는 아예 없어서 라이브러리를 import하지 않는이상 답이 없음..

- 여담
  - 개발시, 자바는 apache commons 나 guava같은 라이브러리 쓰는게 좋다.
  - 아마 spring은 제공하는 utils를 이용하는게 좋을듯.

## 3장 파이썬 (3.7기준)

- 인덴트
  - pep8 기준 공백 4칸이 원칙
- 네이밍 컨벤션
  - java랑은 다르게 snake_case가 원칙

- 타입힌트는 써주는게 좋다.
  - 타입힌트는 타입을 강제하는 기능은 아니다.
    - > 당연
  - 근데 보통 코테에서는 알고리즘이 짧아서 이게 필요 없기는 하지만, 코드 정리시에는 추가하는게 면접관에제 좋은 점수를 받는다.
  - 온라인 코테에서는 `pip install mypy` 사용하면 된다네. 80p

- 리스트 컴프리헨션
  - 기존 리스트를기반으로 새로운 리스트를 만드는 구문
  - map, filter 를 python에서 제공하지만, 이거 대신 쓰는거 추천 ( effective python에도 나온 내용)
    - > 가독성이 좋기 떄문
  - 파이썬 2.7 이후에서는 list 뿐만아니라 dict도 컴프리헨션 가능 👍
  - 표현식은 2개 이상이 넘지 않아야 한다. (가독성 떄문)

- 제너레이터
  - 대표 함수 : range
    - python 2에서는 xrange가 제너레이터 이용한 함수 였음
  - > 제너레이터 동작은 따로 정리한거 보면 좋음. 이거 생각보단 복잡했음
  - 제너레이터에 index operation도 가능 👍
  - 메모리 점유율에 유리 하니까. 권장하는듯.

- enumerate
  - 인덱스 자동 부여

- 나눗셈(86p) 👍
  - 파이썬 3 이상
    - `/` ,`//` 두가지가 다름 
      - `5//3` 은 `int(5/3)`과 같음. 즉 몫만 가져오는것
    - 나머지 연산은 %
  - 몫 나머지 동시 연산은 divmod() 함수 써야함

- print  (87p)
  - f-string 밑 기타 디버깅에 도움되는 내용 있음
  - f-string은 3.6 이상에서만 가능

- locals() : 90p
  - > 디버깅에 도움 된다는데..

- 클린코드에서는 주석은 없는게 좋다고 했으나, java외 다른 언어에서는 논란의 여지가 있음
  - > 코딩 인터뷰에서는 주석 있는게 좋음

- 구글 파이썬 가이드 :95p 👍
  - > 한번 봐 둘것

## 4장 빅오, 자료형

- 빅오 정리 :101p
  - O(1)
    - 해시 테이블의 조회 및 삽입
  - O(log n)
    - 이진 검색
  - O(n)
    - linear-time 알고리즘
    - 정렬되지 않은 List에서 최소값, 최대값 찾는거.. 이값을 찾으려면 모든 값을 최소 1번은 봐야함
  - O(n logn)
    - 병합 정렬 등, 대부분의 효율좋은 알고리즘들이 여기에 해당
    - 적어도 모든 수를 한번은 비교해야하는, 비교기반 정렬 알고리즘은 이거보다 빠를수는 없음. 아무리 좋은 알고리즘이어도..
      - 물론 입력값이 최선인경우 비교를 건너뛰어서 O(n)이 가능 => timsort가 그러함
  - O(n^2)
    - 버블 정렬같은 비효율적 알고리즘들.
  - O(2^n)
    - 피보나치수 재귀 계산
  - O(n!)
    - 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제 (TSP문제) 를 브루트 포스로 풀면 여기에 해당

- 메모리 사용량과 알고리즘 속도는 트레이드 오프 관계, 보통 둘다 좋을수는 없다. 
- 최근에는 병렬처리가 가능한 알고리즘이냐 아니냐가 좋은 알고리즘의 척도가 되기도 함

- 파이썬 자료형 
  - 107p 계층 구조 볼만함.
  - 파이썬은 2와 3이 자료형에 차이가 조금 있다. 

- 숫자
  - 2에서는 int,long
    - Fixed-precision, and Arbitrary-precision
  - 2.4에서는 int쓰다 부족하면 자동으로 long이 되었음
  - 3부터는 Int만 존재
    - 단, int가 arbitrary-precision임
    - > 자세한것은 109p
  - bool 은 Int의 서브 클래스
    - 내부적으로 1과 0으로 처리됨
    - `Ture == 1` 값은 True가 나옴
  - int는 object의 하위 클래스
- 매핑
  - 딕셔너리
    - > 이거 3부터 입력 순서 유지 된다고 한거 같은데..
- 집합
  - set
    - 모르고 있었는데, set에는 list를 넣을수가 없다. 왜냐면 list를 넣으면 list가 가변이기 때문.
    - set 자체는 불변 data는 아님
    - `a = set()`
    - `a = {1,2,3}` // 초기값있을떄 이렇게 할수 있음
      - `a = {}` 이건 set이 아니라 dict임. 주의 필요
    - 그리고 set은 입력 순서 유지 안됨
- 시퀀스
  - str, bytes, tuple => imutable
    - > 튜플은 입력 순서 보장 되나봄
  - list => mutable
- is vs ==
  - is 는 id()값 즉 주소값 비교
  - == 는 실제 값 비교

- 파이썬의 모든 자료형은 객체임.
  - 자바의 primitive type 말고 boxing된 객체 타입 있는거.. 그거라고 보면됨
 
- 119p 파이썬 정수형 구조 신기.

## 5장. 리스트, 딕셔너리

이거 두개는 코테 모든 문제에 쓰임
  
> 아.. 책내용 진짜 괜찮네..

- 리스트 123p
  - 내부적으로 동적 배열로 구성됨
    - > 자바 ArrayList 같은거
  - 입력 순서 유지됨
  - 스택, 큐 연산 모두 지원
    - 스택 연산은 보통 O(1)
    - 큐 연산은 O(n)따라서 큐 연산을 위주로 쓸꺼면 deque를 쓴는게 좋다.
  - 주요 연산
    - a.pop() : 이건 스택연산. O(1). 리스트의 마지막 요소 추출
      - > 리스트 메서드들은 리스트를 스택으로 사용하기 쉽게 만드는데, 마지막에 넣은 요소가 처음으로 꺼내지는 요소입니다
      - > https://docs.python.org/ko/3/tutorial/datastructures.html
        - 책 내용이 여기 내용 복붙같네..
    - a.pop(0) : 이건 큐 연산. O(n) -> 리스트 첫번째 요소 추출하는거는 맞는데, 이건 전체 복사가 필요하다고 함 그래서 O(n)
      - > 0 대신 다른 index를 넣으면 해당 요소 빼줌.
      - >  리스트의 끝에 덧붙이거나, 끝에서 꺼내는 것은 빠르지만, 리스트의 머리에 덧붙이거나 머리에서 꺼내는 것은 느립니다 (다른 요소들을 모두 한 칸씩 이동시켜야 하기 때문입니다
      - > 큐를 구현하려면, 양 끝에서의 덧붙이기와 꺼내기가 모두 빠르도록 설계된 collections.deque 를 사용하세요
    - a.sort() : Timsort 최선의 경우 O(n) 도 가능 보통 O(n logn)
    - a.reverse() : O(n) 이거 list에만 제공됨. str에는 없음
    - elem in a : O(n)
    - 슬라이싱
      - O(k) k는 슬라이싱할 요소 갯수
      - https://robotai.tistory.com/27
      - 슬라이싱은 새로운 객체를 만들어 내는것
      - 슬라이싱은 원래 문자열에 유용하게 활용되는 기술

- 딕셔너리
  - python 3.7 부터는 입력순서 유지됨
    - 다만 여전히 3.6 이하를 사용하는 곳이 많으니, 항상 이럴꺼라고 생각하면 안됨
    - 이땐, collectins.OrderedDict()를 써야함
    - > 코테에서 인터프리터 버전을 확인할수 있으면 확인하고 진행하는것이 좋을듯
  - 내부적으로는 해시테이블로 만들어짐
    - 해시 테이블 원리
      - https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table해시-해싱-해시테이블-자료구조의-이해-6ijyonph6o
  - 해시만 가능하면 어떤 type이던지 key로 사용할수 있음. 단 불변객체여야하고.
  - 대부분의 연산은 O(1) 복잡도.
    - `key in a` -> key가 dict a에 있는지 확인하는거. 이것도 당연히 O(1)
  - 3.6이상부터는 dict의 메모리 사용량도 20%정도 감소 되었음 -> 성능 개선된것
  - collections 모듈의 딕셔너리를 효율적으로 생성하는 모듈들 매우 유용하다
    - collections.defaultdict()
    - collections.Counter()
    - collections.OrderedDict()
  - keyError
    - 없는키를 접근하면 발생
    - 이거 try except로 잡아서 해당 key/value를 삽입하는등 유용하게 써먹을수 있음
    - 물론 `key in a` 처럼 키가 있는지 미리 확인하는 방법도 있음
    - list에서는 IndexError가 있었음. 비슷하게..

- 딕셔너리 모듈
  - defaultdict 객체
    - 키가 없어도 default 값을 갔는 value를 넣어줌 (원랜 KeyError가 나야함.)
    - `a = collections.defaultdict(int)` // 이러면 int의 default값인 0이 없는 키를 조회 했을때 value로 들어감
  - Counter 객체 👍
    - `a = [1,2,3,4,5,5,5,6,6]`
    - ` b = collections.Counter(a)` 
    - b를 출력하면 다음과 같다. 
      - `Counter({5:3, 6:2, 1:1, 2:1, 3:1, 4:1})`
    - 즉 카운터 객체는 list 같은걸 받아서, key는 item, value는 해당 item이 나온횟수를 가지고 dict를 만들어 준다 
      - 물론 실제로는 dict를 한번더 wrapping한 collections.Counter 이긴함
    - Counter 객체에서 가장 빈도가 높은 요소 추출은?
      - `b.most_common(2)` param은 빈도 높은 요소 몇개 뽑을지
      - 결과는 `[(5,3),(6,2)]`
  - OrderedDict 객체
    - 3.6 이하면 쓴다. 
  - 지원하는 method
    - https://wikidocs.net/16

## 6장. 문자열 조작

여기서 부터는 문제 풀이를 하며, 문자열 조작하는 법을 알아봄.  
문자열 조작은 단골 문제니까 알아두면 좋음.  
문자열 조작을 위한 필수 method 들이 쫌 있네.. 알아둬야할.. 특히 str 타입에 생각보다 다양한 method가 있음

- 125. 팰린드 룸 문제 
  - 팰린드룸이란 뒤집어서 원본이랑 같은 문자인거
  - 풀이 1
    - 문자열로 조건 처리하는거 중요
    - list의 pop연산 중요
  - 풀이 2
    - deque 가 뛰어남 
  - 풀이 3
    - > python 스럽게 풀었음
    - 그냥 문자열 뒤집은거 만들어서, 원본이랑 비교
      - `s[::-1]` 이게 내부적으로 C로 구현되어 있어서 빠르다고 함
        - > `::` 이 두개 인거 주목 
        - > `-` 개념을 이해하는 것이 좋은데. - 는 맨뒤에서 부터라고 이해하면 좋을듯. 즉 오른쪽 진행방향 이고 맨뒤를 의미 한다 보면된다.
    - 그리고 정규식으로 불필요 문자열 제거한거 중요
      - > 이거는 O(1) 인가봄..
      - > 즉, 정규식 잘 알아야함 ( 그래서 플젝에서도 정규식을 이용했던건가? 빨라서?)
      - `re.sub(pattern, repl, string, count=0, flags=0)`
        - substitution 임. 즉 치환, string에서 pattern에 맞는것은 replace 값으로 치환
    - 풀이 4
      - C로 구현. 풀이3 보다 9배 빠름..

- 344. 문자열 뒤집기
  - 트릭 신기.
  - 풀이는 별게 없음

- 937. 로그파일 재정렬
  - 요구 조건을 처리할수 있는지 묻는 문제
  - 관전 포인트
    - str.split()
      - https://docs.python.org/ko/3/library/stdtypes.html?highlight=split
      - sep param이 없으면 공백 등으로 문자열을 분할
      - 반환은 list이다
    - str.isdigit()
      - 문자가 순자인지 판단
    - 파이썬 람다
    - list.sort(key=)
      - > sorted도 마찬가지
      - key에 람다를 넣는데 return을 튜플로 해서, 여러 조건을 줄수가 있음
      - https://dailyheumsi.tistory.com/67
    - list + 연산
    - 150p 확인할것!
- 819. 가장 흔한 단어
  - 역시 정규식
  - 그리고 collections.Counter 이용. 여기서 most_common()은 튜플 List 반환이라는거 주의
    - collections.Counter(words) 여기서 param은 iterable이 들어가야함.
      - iterable 
        - https://wikidocs.net/16068
  - max() 및 dict의 get 함수
    - > 즉, dict에서 Key 나 value를 추출할줄 알아야한다.
  - 파라메터 바인딩
    - `return max(counts, key=counts.get)` 에서 counts.get 같은경우 dict의 get method를 넘긴건데, this가 이미 counts로 고정된것.
    - > Python의 class 및 method잘 알아야할듯..

- 49. 그룹 애너그램
  - 애너그램 문자열은 정렬하면 각각 같아지네.
  - ` "".join(sorted("ste")) ` -> 문자열을 sorted 함수에 넣으면 정렬된 list가 나옴. 그래서 "".join으로 다시 문자열로 만들어줌
  - ` list(anagrams.values())` -> dict의 values를 쓰면 dict의 value값만 나오는데, 이거 list가 아닌 specific한 객체임 (py3)
    - 그래서 list를 통해 다시 list를 만들어줌
  - `anagrams = collections.defaultdict(list) # list를 요소로 같는 dict를 만듬`
  - **여러가지 정렬방법**
    - 여기서는 파이썬 정렬 함수의 기능 관련 내용만 소개 ( 정렬은 17장 주제 ) -> 155p
    - list의 sort 함수는 in place sort 따라서 추가 공간이 필요하지 않음
      - `alist.sort()` 의 경우 None을 return.. 당연
      - sorted()는 정렬된 list를 반환하니까 추가 공간이 필요한것
    - 파이썬은 팀소트를 정렬 알고리즘으로 사용하는데 이것은 java7에서 자바 컬렉션의 공식 정렬 알고리즘으로 사용되기도 함

- 5. 가장 긴 팰린드롬 부분 문제
  - > 나 이거 못풀었던거 같음
  - Longest Common String 문제
    - 여러개의 입력 문자열이 있을때 서로 공통된 가장 긴 부분 문자열 찾는거
    - 컴퓨터 과학의 오랜 문제라고 함
    - 다이나믹 프로그래밍으로 푸는 전형적인 문제
    - 이문제도 다이나믹으로 풀수는 있지만. 예상과 달리 수행 시간이 느림
  - 풀이법
    - 슬라이딩 윈도우 2짜리 3짜리 준비 -> 투 포인터 유사.
    - 왜냐면 팰린드가 짝수 문자, 혹은 홀수 문자열일수 있어서..
    - 위 윈도우를 움직여서 팰린드 찾고
      - 이때 슬라이딩 윈도우는 필린드를 찾았어도, 뒤에 또 있을수 있으니 끝가진 가야함
    - 찾았을 떄마다 양옆을 확장해서 팰린드인지 확인
    - > 상당히 간단한 idea임.
  - 예외 처리 
    - 예외 케이스를 먼저 처리해줌
  - max() 함수 👍
    - max(iterable, *[, key, default])
    - max(arg1, arg2, *args[, key])

- 유니코드와 UTF-8
  - 유니코드는 2~4바이트 공간을 사용. 영문자도 2byte 이상의 공간을 사용해서 표현
    - > 즉 항상 2바이트 인게 아니었음..
  - 이걸 가변 길이 문자 인코딩 방식으로 효율적으로 인코딩하는 방식이 UTF-8
    - > 즉, 유니코드 문자에 대한 인코딩 방식이라고 보면될듯
    - > 추가적으로 아스키는 1byte이지만 1bit는 체크섬으로 사용해서 실질적으로 7bit로만 문자를 표현 그래서 128글짜만 표현 가능
  - 파이썬 3 문자열은 유니코드를 사용하지만 내부적으로 UTF-8 인코딩을 사용하지는 않음
    - 왜냐면, 이건 가변길이 문자가 되어서 index로 문자를 찾아가기가 쉽지 않음
    - 따라서 문자열에 포함됨 문자의 최대 size에 맞추어서 모든 문자을 같은 size로 만들어서 문자열로 관리 -> 165p
      - 즉, Latin-1, UCS-2 등의 인코딩을 활용하게 됨
    - 164p에 UTF-8 인코딩에 대한 내용 있는데 쉽네.

- TIP
  - 문자열 조작할 때는, 항상 슬라이싱을 우선 사용해라 
    - 문자열을 별도 List로 매핑하는 등의 처리는 상당한 연산 비용이 필요해서 속도 측면에서 손해 -> 143p 반드시 확인 👍
    - list의 reverse() 보다도 빠름
    - > 문자열 슬라이싱만 빠르나? -> 모든 슬라이싱이 빠르나봄
  - 온라인 코테에서는 별다른 제약이 없다면 파이썬 내장 함수를 사용하는 편이 속도가 빠르다 -> 내부적으로 c라서 -> 156p
    - > sorted() 함수 말하는거 같음.

